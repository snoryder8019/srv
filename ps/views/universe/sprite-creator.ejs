<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sprite Atlas Creator - Stringborn Universe</title>
  <link rel="stylesheet" href="/stylesheets/style.css">
  <style>
    .sprite-creator-container {
      max-width: 1400px;
      margin: 2rem auto;
      padding: 2rem;
      background: rgba(20, 20, 40, 0.95);
      border-radius: 12px;
      border: 2px solid #8a4fff;
    }

    .creator-header {
      text-align: center;
      margin-bottom: 2rem;
    }

    .creator-header h1 {
      color: #8a4fff;
      font-size: 2.5rem;
      margin-bottom: 0.5rem;
    }

    .creator-header p {
      color: #aaa;
      font-size: 1.1rem;
    }

    .creator-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
      margin-bottom: 2rem;
    }

    .creator-section {
      background: rgba(0, 0, 0, 0.3);
      padding: 1.5rem;
      border-radius: 8px;
      border: 1px solid #444;
    }

    .creator-section h2 {
      color: #8a4fff;
      font-size: 1.5rem;
      margin-bottom: 1rem;
      border-bottom: 2px solid #8a4fff;
      padding-bottom: 0.5rem;
    }

    .canvas-container {
      position: relative;
      width: 640px;
      height: 640px;
      margin: 1rem auto;
      border: 2px solid #8a4fff;
      background: #000;
      cursor: crosshair;
    }

    #spriteCanvas {
      width: 100%;
      height: 100%;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }

    .grid-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .form-group {
      margin-bottom: 1.5rem;
    }

    .form-group label {
      display: block;
      color: #8a4fff;
      font-weight: bold;
      margin-bottom: 0.5rem;
    }

    .form-group input,
    .form-group select,
    .form-group textarea {
      width: 100%;
      padding: 0.75rem;
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid #444;
      border-radius: 4px;
      color: #fff;
      font-size: 1rem;
    }

    .form-group textarea {
      resize: vertical;
      min-height: 80px;
    }

    .tile-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 0.5rem;
      margin-top: 1rem;
    }

    .tile-item {
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid #444;
      padding: 0.5rem;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
    }

    .tile-item:hover {
      border-color: #8a4fff;
      background: rgba(138, 79, 255, 0.1);
    }

    .tile-item.selected {
      border-color: #00ff88;
      background: rgba(0, 255, 136, 0.2);
    }

    .tile-item .tile-index {
      color: #8a4fff;
      font-weight: bold;
      font-size: 0.9rem;
    }

    .tile-item .tile-category {
      color: #aaa;
      font-size: 0.75rem;
      margin-top: 0.25rem;
    }

    .file-upload-zone {
      border: 2px dashed #8a4fff;
      padding: 2rem;
      text-align: center;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
      margin-bottom: 1rem;
    }

    .file-upload-zone:hover {
      background: rgba(138, 79, 255, 0.1);
      border-color: #00ff88;
    }

    .file-upload-zone.dragover {
      background: rgba(0, 255, 136, 0.2);
      border-color: #00ff88;
    }

    .upload-icon {
      font-size: 3rem;
      margin-bottom: 1rem;
    }

    .btn {
      padding: 0.75rem 2rem;
      border: none;
      border-radius: 6px;
      font-size: 1rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
    }

    .btn-primary {
      background: linear-gradient(135deg, #8a4fff 0%, #00ff88 100%);
      color: #fff;
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 20px rgba(138, 79, 255, 0.5);
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
      border: 1px solid #444;
    }

    .btn-secondary:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .button-group {
      display: flex;
      gap: 1rem;
      justify-content: center;
      margin-top: 2rem;
    }

    .alert {
      padding: 1rem;
      border-radius: 6px;
      margin-bottom: 1rem;
      display: none;
    }

    .alert.success {
      background: rgba(0, 255, 136, 0.2);
      border: 1px solid #00ff88;
      color: #00ff88;
    }

    .alert.error {
      background: rgba(255, 79, 79, 0.2);
      border: 1px solid #ff4f4f;
      color: #ff4f4f;
    }

    .spec-info {
      background: rgba(138, 79, 255, 0.1);
      border: 1px solid #8a4fff;
      padding: 1rem;
      border-radius: 6px;
      margin-bottom: 1rem;
    }

    .spec-info h3 {
      color: #8a4fff;
      margin-bottom: 0.5rem;
    }

    .spec-info ul {
      color: #aaa;
      padding-left: 1.5rem;
    }

    .spec-info li {
      margin-bottom: 0.25rem;
    }

    .planet-type-selector {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 1rem;
      margin: 1rem 0;
    }

    .planet-type-card {
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid #444;
      padding: 1rem;
      border-radius: 8px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
    }

    .planet-type-card:hover {
      border-color: #8a4fff;
      transform: translateY(-2px);
    }

    .planet-type-card.selected {
      border-color: #00ff88;
      background: rgba(0, 255, 136, 0.1);
    }

    .planet-type-card .type-icon {
      font-size: 2.5rem;
      margin-bottom: 0.5rem;
    }

    .planet-type-card .type-name {
      color: #fff;
      font-weight: bold;
    }

    /* Hitbox Layer Styles */
    .layer-toggle {
      display: flex;
      gap: 0.5rem;
      margin: 1rem 0;
    }

    .layer-button {
      flex: 1;
      padding: 0.5rem 1rem;
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid #444;
      color: #fff;
      cursor: pointer;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .layer-button:hover {
      border-color: #8a4fff;
    }

    .layer-button.active {
      background: rgba(138, 79, 255, 0.3);
      border-color: #8a4fff;
      color: #8a4fff;
      font-weight: bold;
    }

    .hitbox-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .hitbox-canvas.active {
      pointer-events: auto;
    }

    .hitbox-info {
      background: rgba(255, 79, 79, 0.1);
      border: 1px solid #ff4f4f;
      padding: 0.75rem;
      border-radius: 4px;
      margin-top: 0.5rem;
      color: #ff9999;
      font-size: 0.875rem;
    }

    .hitbox-tools {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    .hitbox-tools button {
      flex: 1;
      padding: 0.5rem;
      background: rgba(255, 79, 79, 0.2);
      border: 1px solid #ff4f4f;
      color: #fff;
      border-radius: 4px;
      cursor: pointer;
    }

    .hitbox-tools button:hover {
      background: rgba(255, 79, 79, 0.3);
    }
  </style>
</head>
<body>
  <%- include('../partials/header') %>

  <div class="sprite-creator-container">
    <div class="creator-header">
      <h1>üé® World Sprite Builder</h1>
      <p>Create 2D sprite atlases for planetary environments, monsters, and terrain</p>
    </div>

    <div class="alert success" id="successAlert"></div>
    <div class="alert error" id="errorAlert"></div>

    <div class="creator-grid">
      <!-- Left Column: Canvas & Upload -->
      <div class="creator-section">
        <h2>1. Create Sprite Atlas</h2>

        <div class="spec-info">
          <h3>Specifications:</h3>
          <ul>
            <li>Size: 80√ó80 pixels (5√ó5 grid of 16√ó16 tiles)</li>
            <li>Display: 640√ó640 pixels (8√ó zoom for easier drawing)</li>
            <li>Format: PNG with transparency</li>
            <li>Max File Size: 50KB</li>
          </ul>
        </div>

        <!-- Mode Tabs -->
        <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
          <button class="btn btn-secondary" id="drawModeBtn" onclick="switchMode('draw')" style="flex: 1;">üé® Draw</button>
          <button class="btn btn-secondary" id="uploadModeBtn" onclick="switchMode('upload')" style="flex: 1;">üì§ Upload</button>
        </div>

        <!-- Layer Toggle -->
        <div class="layer-toggle">
          <button class="layer-button active" id="spriteLayerBtn" onclick="switchLayer('sprite')">
            üé® Sprite Layer
          </button>
          <button class="layer-button" id="hitboxLayerBtn" onclick="switchLayer('hitbox')">
            üî¥ Hitbox Layer
          </button>
        </div>
        <div class="hitbox-info" id="hitboxInfo" style="display: none;">
          <strong>Hitbox Layer Active:</strong> Draw collision/damage zones in red. These define interactive areas for combat, collision detection, and triggers.
        </div>

        <!-- Draw Mode -->
        <div id="drawMode" style="display: block;">
          <div id="pixelEditorContainer"></div>
        </div>

        <!-- Upload Mode -->
        <div id="uploadMode" style="display: none;">
          <div class="file-upload-zone" id="uploadZone">
            <div class="upload-icon">üì§</div>
            <p>Drag & drop your 80√ó80 PNG here</p>
            <p style="color: #aaa; font-size: 0.9rem;">or click to browse</p>
            <input type="file" id="fileInput" accept="image/png" style="display: none;">
          </div>
        </div>

        <!-- Preview Canvas -->
        <div style="margin-top: 1rem;">
          <p style="color: #aaa; font-size: 0.9rem; margin-bottom: 0.5rem; text-align: center;">
            üìã Click a tile to copy, then click another to paste
          </p>
          <div class="canvas-container">
            <canvas id="spriteCanvas" width="80" height="80"></canvas>
            <canvas id="hitboxCanvas" class="hitbox-canvas" width="80" height="80"></canvas>
            <canvas class="grid-overlay" id="gridCanvas" width="640" height="640"></canvas>
          </div>
        </div>

        <!-- Hitbox Tools -->
        <div class="hitbox-tools" id="hitboxTools" style="display: none;">
          <button onclick="clearHitboxLayer()">üóëÔ∏è Clear Hitboxes</button>
          <button onclick="toggleHitboxVisibility()">üëÅÔ∏è Toggle Visibility</button>
          <button onclick="exportHitboxData()">üíæ Export Hitbox Data</button>
        </div>

        <div style="display: flex; gap: 0.5rem; margin-top: 1rem;">
          <button class="btn btn-secondary" onclick="updatePreview()" style="flex: 1;">üîÑ Update Preview</button>
          <button class="btn btn-secondary" onclick="clearCanvas()" style="flex: 1;">üóëÔ∏è Clear Canvas</button>
          <button class="btn btn-secondary" onclick="cancelCopy()" style="flex: 1;">‚ùå Cancel Copy</button>
        </div>
      </div>

      <!-- Right Column: Metadata & Configuration -->
      <div class="creator-section">
        <h2>2. Configure Atlas</h2>

        <form id="atlasForm">
          <div class="form-group">
            <label for="atlasName">Atlas Name *</label>
            <input type="text" id="atlasName" placeholder="e.g., Forest Terrain Pack" required>
          </div>

          <!-- Conditional Context Selector (changes based on pack type) -->
          <div class="form-group" id="contextSelectorGroup">
            <label id="contextLabel">Context / Category *</label>
            <div class="planet-type-selector" id="contextSelector">
              <!-- Context options will be generated here based on pack type -->
            </div>
            <input type="hidden" id="selectedContext" required>
          </div>

          <div class="form-group">
            <label for="packType">Pack Type *</label>
            <select id="packType" required>
              <optgroup label="Environment Packs">
                <option value="terrain">Terrain Pack (Top-Down)</option>
                <option value="dungeon">Dungeon Pack (Top-Down)</option>
                <option value="ship_interior">Ship Interior (Top-Down)</option>
                <option value="inn">Inn/Tavern (Top-Down)</option>
                <option value="fortress">Fortress/Castle (Top-Down)</option>
              </optgroup>
              <optgroup label="Character Packs">
                <option value="monsters">Monster Pack</option>
                <option value="npcs">NPC Pack</option>
              </optgroup>
              <optgroup label="Side-Scroller Packs">
                <option value="dungeon_sidescroll">Dungeon (Side-Scroller)</option>
                <option value="asteroids">Asteroids (Side-Scroller)</option>
              </optgroup>
              <optgroup label="Structure Packs">
                <option value="buildings">Building Pack</option>
              </optgroup>
            </select>
          </div>

          <div class="form-group">
            <label for="description">Description</label>
            <textarea id="description" placeholder="Describe your sprite pack..."></textarea>
          </div>

          <h3 style="color: #8a4fff; margin-top: 2rem;">3. Tile Categories</h3>
          <div id="packTypeInfo" style="background: rgba(138, 79, 255, 0.1); border: 1px solid #8a4fff; padding: 1rem; border-radius: 6px; margin-bottom: 1rem;">
            <p style="color: #8a4fff; font-weight: bold; margin: 0 0 0.5rem 0;">Current Rules: Terrain Pack</p>
            <p style="color: #aaa; font-size: 0.9rem; margin: 0;">Each row follows specific naming and animation rules for rendering.</p>
          </div>

          <div class="tile-grid" id="tileGrid">
            <!-- Tiles will be generated here -->
          </div>
        </form>
      </div>
    </div>

    <div class="button-group">
      <button class="btn btn-secondary" onclick="window.history.back()">Cancel</button>
      <button class="btn btn-primary" onclick="submitAtlas()">üöÄ Upload Sprite Atlas</button>
    </div>
  </div>

  <script src="/javascripts/pixel-editor.js"></script>
  <script src="/javascripts/sprite-loader.js"></script>
  <script>
    const canvas = document.getElementById('spriteCanvas');
    const ctx = canvas.getContext('2d');
    const gridCanvas = document.getElementById('gridCanvas');
    const gridCtx = gridCanvas.getContext('2d');
    const hitboxCanvas = document.getElementById('hitboxCanvas');
    const hitboxCtx = hitboxCanvas.getContext('2d');

    let uploadedImage = null;
    let tileManifest = [];
    let pixelEditor = null;
    let currentMode = 'draw';
    let currentLayer = 'sprite';
    let copiedTileData = null;
    let selectedTileX = -1;
    let selectedTileY = -1;
    let hitboxData = {}; // Store hitbox data per tile
    let hitboxVisible = true;
    let isDrawingHitbox = false;
    let hitboxStartX = 0;
    let hitboxStartY = 0;

    // Context options for each pack type
    const CONTEXT_OPTIONS = {
      terrain: {
        label: 'Planet Biome',
        options: [
          { type: 'forest', name: 'Forest', icon: 'üå≤' },
          { type: 'desert', name: 'Desert', icon: 'üèúÔ∏è' },
          { type: 'ocean', name: 'Ocean', icon: 'üåä' },
          { type: 'volcanic', name: 'Volcanic', icon: 'üåã' },
          { type: 'ice', name: 'Ice', icon: '‚ùÑÔ∏è' },
          { type: 'grassland', name: 'Grassland', icon: 'üåæ' },
          { type: 'tundra', name: 'Tundra', icon: 'üèîÔ∏è' },
          { type: 'swamp', name: 'Swamp', icon: 'üêä' },
        ]
      },
      dungeon: {
        label: 'Dungeon Theme',
        options: [
          { type: 'crypt', name: 'Crypt', icon: '‚ö∞Ô∏è' },
          { type: 'cave', name: 'Cave', icon: 'üóø' },
          { type: 'ruins', name: 'Ancient Ruins', icon: 'üèõÔ∏è' },
          { type: 'sewer', name: 'Sewer', icon: 'üö∞' },
          { type: 'prison', name: 'Prison', icon: 'üîí' },
          { type: 'temple', name: 'Temple', icon: '‚õ©Ô∏è' },
        ]
      },
      ship_interior: {
        label: 'Ship Class',
        options: [
          { type: 'fighter', name: 'Fighter', icon: 'üöÄ' },
          { type: 'freighter', name: 'Freighter', icon: 'üì¶' },
          { type: 'cruiser', name: 'Cruiser', icon: 'üõ∏' },
          { type: 'battleship', name: 'Battleship', icon: '‚öîÔ∏è' },
          { type: 'colony', name: 'Colony Ship', icon: 'üèôÔ∏è' },
          { type: 'science', name: 'Science Vessel', icon: 'üî¨' },
        ]
      },
      inn: {
        label: 'Era / Culture',
        options: [
          { type: 'medieval', name: 'Medieval', icon: 'üè∞' },
          { type: 'western', name: 'Western', icon: 'ü§†' },
          { type: 'fantasy', name: 'High Fantasy', icon: 'üßô' },
          { type: 'pirate', name: 'Pirate Den', icon: 'üè¥‚Äç‚ò†Ô∏è' },
          { type: 'steampunk', name: 'Steampunk', icon: '‚öôÔ∏è' },
          { type: 'scifi', name: 'Sci-Fi Cantina', icon: 'üõ∏' },
        ]
      },
      fortress: {
        label: 'Architectural Style',
        options: [
          { type: 'human', name: 'Human Castle', icon: 'üè∞' },
          { type: 'elven', name: 'Elven Citadel', icon: 'üåü' },
          { type: 'dwarven', name: 'Dwarven Hold', icon: '‚õèÔ∏è' },
          { type: 'orcish', name: 'Orc Stronghold', icon: '‚öîÔ∏è' },
          { type: 'dark', name: 'Dark Fortress', icon: 'üåë' },
          { type: 'oriental', name: 'Oriental Palace', icon: 'üèØ' },
        ]
      },
      dungeon_sidescroll: {
        label: 'Difficulty / Theme',
        options: [
          { type: 'beginner', name: 'Beginner', icon: 'üü¢' },
          { type: 'intermediate', name: 'Intermediate', icon: 'üü°' },
          { type: 'expert', name: 'Expert', icon: 'üî¥' },
          { type: 'lava', name: 'Lava Temple', icon: 'üåã' },
          { type: 'ice', name: 'Ice Cavern', icon: '‚ùÑÔ∏è' },
          { type: 'toxic', name: 'Toxic Ruins', icon: '‚ò¢Ô∏è' },
        ]
      },
      asteroids: {
        label: 'Game Mode',
        options: [
          { type: 'arcade', name: 'Arcade', icon: 'üïπÔ∏è' },
          { type: 'survival', name: 'Survival', icon: '‚è±Ô∏è' },
          { type: 'boss_rush', name: 'Boss Rush', icon: 'üëæ' },
          { type: 'exploration', name: 'Exploration', icon: 'üó∫Ô∏è' },
          { type: 'mining', name: 'Mining', icon: '‚õèÔ∏è' },
          { type: 'combat', name: 'Combat', icon: 'üí•' },
        ]
      },
      monsters: {
        label: 'Faction / Type',
        options: [
          { type: 'undead', name: 'Undead', icon: 'üíÄ' },
          { type: 'beast', name: 'Beast', icon: 'üê∫' },
          { type: 'demon', name: 'Demon', icon: 'üòà' },
          { type: 'elemental', name: 'Elemental', icon: 'üî•' },
          { type: 'insectoid', name: 'Insectoid', icon: 'üêõ' },
          { type: 'alien', name: 'Alien', icon: 'üëΩ' },
        ]
      },
      npcs: {
        label: 'Faction / Role',
        options: [
          { type: 'civilian', name: 'Civilian', icon: 'üë§' },
          { type: 'merchant', name: 'Merchant', icon: 'üí∞' },
          { type: 'guard', name: 'Guard', icon: 'üõ°Ô∏è' },
          { type: 'noble', name: 'Noble', icon: 'üëë' },
          { type: 'guild', name: 'Guild Member', icon: '‚öíÔ∏è' },
          { type: 'clergy', name: 'Clergy', icon: '‚úùÔ∏è' },
        ]
      },
      buildings: {
        label: 'Tech Level',
        options: [
          { type: 'primitive', name: 'Primitive', icon: 'ü™®' },
          { type: 'medieval', name: 'Medieval', icon: 'üè∞' },
          { type: 'industrial', name: 'Industrial', icon: 'üè≠' },
          { type: 'modern', name: 'Modern', icon: 'üè¢' },
          { type: 'scifi', name: 'Sci-Fi', icon: 'üöÄ' },
          { type: 'alien', name: 'Alien Tech', icon: 'üëΩ' },
        ]
      }
    };

    // Tile categories by row (as per spec) - varies by pack type
    const PACK_TYPE_RULES = {
      terrain: {
        name: 'Terrain Pack',
        rows: [
          { name: 'Ground Texture', desc: 'Base terrain tiles (grass, sand, dirt, water)', tiles: ['Primary', 'Light', 'Dark', 'Transition', 'Special'] },
          { name: 'Environment Object', desc: 'Static objects (trees, rocks, bushes)', tiles: ['Small', 'Medium', 'Large', 'Special 1', 'Special 2'] },
          { name: 'Monster Animation', desc: 'Creature 5-frame animation', tiles: ['Idle', 'Walk 1', 'Walk 2', 'Attack', 'Hit/Death'] },
          { name: 'Aerial Effect', desc: 'Clouds and weather effects', tiles: ['Cloud 1', 'Cloud 2', 'Cloud 3', 'Weather 1', 'Weather 2'] },
          { name: 'Resource Nodes', desc: 'Harvestable resources', tiles: ['Ore 1', 'Ore 2', 'Ore 3', 'Plant 1', 'Plant 2'] }
        ]
      },
      monsters: {
        name: 'Monster Pack',
        rows: [
          { name: 'Monster 1 Animation', desc: 'First creature 5-frame cycle', tiles: ['Idle', 'Walk 1', 'Walk 2', 'Attack', 'Hit/Death'] },
          { name: 'Monster 2 Animation', desc: 'Second creature 5-frame cycle', tiles: ['Idle', 'Walk 1', 'Walk 2', 'Attack', 'Hit/Death'] },
          { name: 'Monster 3 Animation', desc: 'Third creature 5-frame cycle', tiles: ['Idle', 'Walk 1', 'Walk 2', 'Attack', 'Hit/Death'] },
          { name: 'Monster 4 Animation', desc: 'Fourth creature 5-frame cycle', tiles: ['Idle', 'Walk 1', 'Walk 2', 'Attack', 'Hit/Death'] },
          { name: 'Monster 5 Animation', desc: 'Fifth creature 5-frame cycle', tiles: ['Idle', 'Walk 1', 'Walk 2', 'Attack', 'Hit/Death'] }
        ]
      },
      npcs: {
        name: 'NPC Pack',
        rows: [
          { name: 'NPC 1 Animation', desc: 'First character 5-frame cycle', tiles: ['Idle', 'Walk 1', 'Walk 2', 'Action', 'Talk'] },
          { name: 'NPC 2 Animation', desc: 'Second character 5-frame cycle', tiles: ['Idle', 'Walk 1', 'Walk 2', 'Action', 'Talk'] },
          { name: 'NPC 3 Animation', desc: 'Third character 5-frame cycle', tiles: ['Idle', 'Walk 1', 'Walk 2', 'Action', 'Talk'] },
          { name: 'NPC 4 Animation', desc: 'Fourth character 5-frame cycle', tiles: ['Idle', 'Walk 1', 'Walk 2', 'Action', 'Talk'] },
          { name: 'NPC 5 Animation', desc: 'Fifth character 5-frame cycle', tiles: ['Idle', 'Walk 1', 'Walk 2', 'Action', 'Talk'] }
        ]
      },
      buildings: {
        name: 'Building Pack',
        rows: [
          { name: 'Hull/Floor Tiles', desc: 'Base structure tiles', tiles: ['Floor 1', 'Floor 2', 'Floor 3', 'Wall', 'Window'] },
          { name: 'Exterior Components', desc: 'Outside parts', tiles: ['Thruster', 'Wing', 'Cockpit', 'Airlock', 'Antenna'] },
          { name: 'Interior Objects', desc: 'Inside furniture', tiles: ['Console', 'Seat', 'Door', 'Panel', 'Storage'] },
          { name: 'UI Elements', desc: 'Placement indicators', tiles: ['Select', 'Valid', 'Invalid', 'Cursor', 'Highlight'] },
          { name: 'Damage States', desc: 'Broken/damaged versions', tiles: ['Broken 1', 'Broken 2', 'Sparking', 'Fire', 'Destroyed'] }
        ]
      },
      dungeon: {
        name: 'Dungeon Pack (Top-Down)',
        rows: [
          { name: 'Floor Tiles', desc: 'Dungeon floor variations', tiles: ['Stone', 'Tile', 'Dirt', 'Cracked', 'Special'] },
          { name: 'Wall Tiles', desc: 'Dungeon walls', tiles: ['Wall 1', 'Wall 2', 'Wall 3', 'Door', 'Window'] },
          { name: 'Objects', desc: 'Dungeon furniture', tiles: ['Chest', 'Barrel', 'Torch', 'Table', 'Rubble'] },
          { name: 'Traps & Hazards', desc: 'Dangerous tiles', tiles: ['Spike', 'Pit', 'Fire', 'Poison', 'Magic'] },
          { name: 'Collectibles', desc: 'Items and rewards', tiles: ['Coin', 'Gem', 'Potion', 'Key', 'Scroll'] }
        ]
      },
      ship_interior: {
        name: 'Ship Interior Pack',
        rows: [
          { name: 'Floor/Hull Tiles', desc: 'Metal floor and hull variations', tiles: ['Metal Floor', 'Grating', 'Damaged', 'Airlock', 'Panel'] },
          { name: 'Wall Sections', desc: 'Interior walls and panels', tiles: ['Wall', 'Window', 'Door', 'Vent', 'Console Panel'] },
          { name: 'Consoles & Stations', desc: 'Interactive ship controls', tiles: ['Helm', 'Engineering', 'Weapons', 'Science', 'Medical'] },
          { name: 'Furniture & Objects', desc: 'Ship interior items', tiles: ['Bed', 'Locker', 'Table', 'Chair', 'Crate'] },
          { name: 'Systems & Effects', desc: 'Ship systems indicators', tiles: ['Power On', 'Alert', 'Damaged', 'Sparks', 'Smoke'] }
        ]
      },
      inn: {
        name: 'Inn/Tavern Pack',
        rows: [
          { name: 'Floor Tiles', desc: 'Inn floor variations', tiles: ['Wood Floor', 'Stone', 'Carpet', 'Stairs', 'Cellar'] },
          { name: 'Wall & Structure', desc: 'Inn walls and supports', tiles: ['Wood Wall', 'Stone Wall', 'Window', 'Door', 'Beam'] },
          { name: 'Furniture', desc: 'Tavern furniture', tiles: ['Table', 'Chair', 'Bar', 'Stool', 'Fireplace'] },
          { name: 'Items & Decor', desc: 'Decorative and interactive items', tiles: ['Barrel', 'Bottle', 'Candle', 'Sign', 'Shelf'] },
          { name: 'NPCs & Patrons', desc: 'Inn character sprites', tiles: ['Barkeep', 'Patron 1', 'Patron 2', 'Bard', 'Server'] }
        ]
      },
      fortress: {
        name: 'Fortress/Castle Pack',
        rows: [
          { name: 'Floor Tiles', desc: 'Castle floor variations', tiles: ['Stone', 'Marble', 'Dirt', 'Grass', 'Courtyard'] },
          { name: 'Wall & Defense', desc: 'Fortress walls and battlements', tiles: ['Stone Wall', 'Battlement', 'Gate', 'Arrow Slit', 'Tower'] },
          { name: 'Structures', desc: 'Castle structures', tiles: ['Throne', 'Banner', 'Pillar', 'Arch', 'Statue'] },
          { name: 'Military Objects', desc: 'Weapons and armor displays', tiles: ['Weapon Rack', 'Armor Stand', 'Shield', 'Banner', 'Brazier'] },
          { name: 'Guards & Nobles', desc: 'Castle inhabitants', tiles: ['Guard', 'Knight', 'Noble', 'Servant', 'King/Queen'] }
        ]
      },
      dungeon_sidescroll: {
        name: 'Dungeon (Side-Scroller)',
        rows: [
          { name: 'Platform Tiles', desc: 'Solid platforms and ledges', tiles: ['Platform L', 'Platform M', 'Platform R', 'Single Block', 'Floating'] },
          { name: 'Background Walls', desc: 'Dungeon background layers', tiles: ['Wall 1', 'Wall 2', 'Wall 3', 'Cracked', 'Decorated'] },
          { name: 'Hazards', desc: 'Side-scroller hazards', tiles: ['Spikes Up', 'Spikes Down', 'Lava', 'Acid', 'Saw Blade'] },
          { name: 'Interactive Objects', desc: 'Platforms and mechanisms', tiles: ['Ladder', 'Rope', 'Moving Platform', 'Spring', 'Switch'] },
          { name: 'Enemy Animations', desc: 'Side-view enemy 5-frame', tiles: ['Idle', 'Walk 1', 'Walk 2', 'Attack', 'Death'] }
        ]
      },
      asteroids: {
        name: 'Asteroids (Side-Scroller)',
        rows: [
          { name: 'Asteroids', desc: 'Various asteroid types', tiles: ['Small 1', 'Small 2', 'Medium 1', 'Medium 2', 'Large'] },
          { name: 'Space Background', desc: 'Background space elements', tiles: ['Star Field', 'Nebula', 'Planet', 'Moon', 'Debris'] },
          { name: 'Ship Frames', desc: 'Player ship animation', tiles: ['Ship Idle', 'Ship Left', 'Ship Right', 'Thrust', 'Shield'] },
          { name: 'Projectiles & Effects', desc: 'Weapons and explosions', tiles: ['Laser', 'Missile', 'Explosion 1', 'Explosion 2', 'Explosion 3'] },
          { name: 'Power-ups & Items', desc: 'Collectible items', tiles: ['Health', 'Shield', 'Weapon', 'Speed', 'Score'] }
        ]
      }
    };

    // Layer switching
    function switchLayer(layer) {
      currentLayer = layer;

      if (layer === 'sprite') {
        document.getElementById('spriteLayerBtn').classList.add('active');
        document.getElementById('hitboxLayerBtn').classList.remove('active');
        document.getElementById('hitboxInfo').style.display = 'none';
        document.getElementById('hitboxTools').style.display = 'none';
        hitboxCanvas.classList.remove('active');
      } else {
        document.getElementById('spriteLayerBtn').classList.remove('active');
        document.getElementById('hitboxLayerBtn').classList.add('active');
        document.getElementById('hitboxInfo').style.display = 'block';
        document.getElementById('hitboxTools').style.display = 'flex';
        hitboxCanvas.classList.add('active');
      }
    }

    // Mode switching
    function switchMode(mode) {
      currentMode = mode;

      if (mode === 'draw') {
        document.getElementById('drawMode').style.display = 'block';
        document.getElementById('uploadMode').style.display = 'none';
        document.getElementById('drawModeBtn').style.opacity = '1';
        document.getElementById('uploadModeBtn').style.opacity = '0.5';

        // Initialize pixel editor if not already done
        if (!pixelEditor) {
          pixelEditor = new PixelEditor('pixelEditorContainer', {
            gridSize: 80,
            pixelSize: 8,
            defaultColor: '#000000'
          });

          // Hook into export to update preview canvas
          const originalExport = pixelEditor.exportToPNG;
          pixelEditor.exportToPNG = function() {
            const exported = originalExport.call(this);
            updatePreviewFromEditor();
            return exported;
          };
        }
      } else {
        document.getElementById('drawMode').style.display = 'none';
        document.getElementById('uploadMode').style.display = 'block';
        document.getElementById('drawModeBtn').style.opacity = '0.5';
        document.getElementById('uploadModeBtn').style.opacity = '1';
      }
    }

    // Update preview canvas from pixel editor
    function updatePreviewFromEditor() {
      if (pixelEditor && pixelEditor.canvas) {
        ctx.clearRect(0, 0, 80, 80);
        ctx.drawImage(pixelEditor.canvas, 0, 0, 80, 80);
      }
    }

    // Generate context options based on pack type
    function generateContextOptions(packType = 'terrain') {
      const contextData = CONTEXT_OPTIONS[packType];
      if (!contextData) return;

      const label = document.getElementById('contextLabel');
      const container = document.getElementById('contextSelector');

      label.textContent = contextData.label + ' *';
      container.innerHTML = contextData.options.map(option => `
        <div class="planet-type-card" onclick="selectContext('${option.type}')">
          <div class="type-icon">${option.icon}</div>
          <div class="type-name">${option.name}</div>
        </div>
      `).join('');
    }

    // Select context option
    function selectContext(type) {
      document.querySelectorAll('.planet-type-card').forEach(card => card.classList.remove('selected'));
      event.target.closest('.planet-type-card').classList.add('selected');
      document.getElementById('selectedContext').value = type;
    }

    // Initialize
    function init() {
      drawGrid();
      generateContextOptions('terrain'); // Default context
      generateTileGrid('terrain'); // Default to terrain
      setupUploadZone();
      switchMode('draw'); // Start in draw mode

      // Add pack type change listener
      const packTypeSelect = document.getElementById('packType');
      packTypeSelect.addEventListener('change', (e) => {
        const packType = e.target.value;
        generateContextOptions(packType); // Update context options
        generateTileGrid(packType);
        showSuccess(`Pack type changed to ${PACK_TYPE_RULES[packType].name}`);
      });
    }

    // Draw 5√ó5 grid overlay
    function drawGrid() {
      gridCtx.clearRect(0, 0, 640, 640);
      gridCtx.strokeStyle = '#8a4fff';
      gridCtx.lineWidth = 2;

      for (let i = 0; i <= 5; i++) {
        // Vertical lines
        gridCtx.beginPath();
        gridCtx.moveTo(i * 128, 0);
        gridCtx.lineTo(i * 128, 640);
        gridCtx.stroke();

        // Horizontal lines
        gridCtx.beginPath();
        gridCtx.moveTo(0, i * 128);
        gridCtx.lineTo(640, i * 128);
        gridCtx.stroke();
      }
    }


    // Generate tile grid based on pack type
    function generateTileGrid(packType = 'terrain') {
      const container = document.getElementById('tileGrid');
      const rules = PACK_TYPE_RULES[packType] || PACK_TYPE_RULES.terrain;
      tileManifest = [];
      container.innerHTML = '';

      // Update pack type info box
      const infoBox = document.getElementById('packTypeInfo');
      infoBox.innerHTML = `
        <p style="color: #8a4fff; font-weight: bold; margin: 0 0 0.5rem 0;">Current Rules: ${rules.name}</p>
        <p style="color: #aaa; font-size: 0.9rem; margin: 0;">
          ${rules.rows.map((r, i) => `Row ${i}: ${r.name}`).join(' ‚Ä¢ ')}
        </p>
      `;

      for (let i = 0; i < 25; i++) {
        const row = Math.floor(i / 5);
        const col = i % 5;
        const rowRule = rules.rows[row];
        const tileName = rowRule.tiles[col];

        tileManifest.push({
          index: i,
          row,
          col,
          name: tileName.toLowerCase().replace(/\s+/g, '_'),
          displayName: tileName,
          category: rowRule.name.toLowerCase().replace(/\s+/g, '_'),
          categoryDisplay: rowRule.name,
          description: rowRule.desc,
          tags: [],
        });

        const tileDiv = document.createElement('div');
        tileDiv.className = 'tile-item';
        tileDiv.innerHTML = `
          <div class="tile-index">${i}: ${tileName}</div>
          <div class="tile-category">${rowRule.name}</div>
        `;
        tileDiv.onclick = () => editTile(i);
        tileDiv.title = `${rowRule.desc}`;
        container.appendChild(tileDiv);
      }
    }

    // Setup upload zone
    function setupUploadZone() {
      const zone = document.getElementById('uploadZone');
      const fileInput = document.getElementById('fileInput');

      zone.onclick = () => fileInput.click();

      fileInput.onchange = (e) => {
        if (e.target.files.length > 0) {
          handleFileUpload(e.target.files[0]);
        }
      };

      zone.ondragover = (e) => {
        e.preventDefault();
        zone.classList.add('dragover');
      };

      zone.ondragleave = () => {
        zone.classList.remove('dragover');
      };

      zone.ondrop = (e) => {
        e.preventDefault();
        zone.classList.remove('dragover');
        if (e.dataTransfer.files.length > 0) {
          handleFileUpload(e.dataTransfer.files[0]);
        }
      };
    }

    // Handle file upload
    function handleFileUpload(file) {
      if (!file.type.startsWith('image/png')) {
        showError('Only PNG files are allowed');
        return;
      }

      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          if (img.width !== 80 || img.height !== 80) {
            showError('Image must be exactly 80√ó80 pixels');
            return;
          }

          uploadedImage = img;
          ctx.clearRect(0, 0, 80, 80);
          ctx.drawImage(img, 0, 0);
          showSuccess('Image loaded successfully!');
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }

    // Edit tile (simple name prompt for now)
    function editTile(index) {
      const tile = tileManifest[index];
      const newName = prompt(`Name for Tile ${index}:`, tile.name);
      if (newName) {
        tile.name = newName;
      }
    }

    // Clear canvas
    function clearCanvas() {
      if (currentMode === 'draw' && pixelEditor) {
        pixelEditor.clearCanvas();
      }
      ctx.clearRect(0, 0, 80, 80);
      uploadedImage = null;
    }

    // Update preview from pixel editor manually
    function updatePreview() {
      if (currentMode === 'draw') {
        updatePreviewFromEditor();
        showSuccess('Preview updated!');
      }
    }

    // Submit atlas
    async function submitAtlas() {
      const name = document.getElementById('atlasName').value;
      const context = document.getElementById('selectedContext').value;
      const packType = document.getElementById('packType').value;
      const description = document.getElementById('description').value;

      if (!name || !context) {
        showError('Please fill in all required fields (name and context)');
        return;
      }

      // Determine which canvas to use based on current mode
      let blob;

      if (currentMode === 'draw') {
        // Use pixel editor - export directly to 80√ó80 blob
        if (!pixelEditor || !pixelEditor.canvas) {
          showError('Please draw something in the pixel editor first');
          return;
        }
        // Get blob from pixel editor (already exports as 80√ó80 with transparency)
        blob = await pixelEditor.exportToBlob();

        // Also update preview canvas
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = 80;
        tempCanvas.height = 80;
        const tempCtx = tempCanvas.getContext('2d');
        const pixelData = pixelEditor.getData();
        for (let y = 0; y < 80; y++) {
          for (let x = 0; x < 80; x++) {
            if (pixelData.pixels[y][x] !== 'transparent') {
              tempCtx.fillStyle = pixelData.pixels[y][x];
              tempCtx.fillRect(x, y, 1, 1);
            }
          }
        }
        ctx.clearRect(0, 0, 80, 80);
        ctx.drawImage(tempCanvas, 0, 0);
      } else {
        // Use uploaded image canvas
        if (!uploadedImage) {
          showError('Please upload a sprite atlas image');
          return;
        }
        blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
      }

      // Submit the blob
      const formData = new FormData();
      formData.append('atlasImage', blob, 'atlas.png');
      formData.append('manifest', JSON.stringify({
        name,
        context, // Contextual category (planet biome, ship class, etc.)
        packType,
        description,
        tiles: tileManifest,
        hitboxes: hitboxData, // Include hitbox data
      }));

      try {
        const response = await fetch('/api/v1/sprite-atlases', {
          method: 'POST',
          body: formData,
        });

        const data = await response.json();

        if (data.success) {
          showSuccess('Sprite atlas uploaded successfully! Redirecting...');
          setTimeout(() => {
            window.location.href = '/universe/galactic-map';
          }, 2000);
        } else {
          showError(data.error || 'Failed to upload atlas');
        }
      } catch (error) {
        showError('Network error: ' + error.message);
      }
    }

    // Show alerts
    function showSuccess(message) {
      const alert = document.getElementById('successAlert');
      alert.textContent = message;
      alert.style.display = 'block';
      setTimeout(() => alert.style.display = 'none', 5000);
    }

    function showError(message) {
      const alert = document.getElementById('errorAlert');
      alert.textContent = message;
      alert.style.display = 'block';
      setTimeout(() => alert.style.display = 'none', 5000);
    }

    // Copy/Paste tile functionality
    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top) * scaleY;

      // Calculate which 16√ó16 tile was clicked (0-4 for x and y)
      const tileX = Math.floor(x / 16);
      const tileY = Math.floor(y / 16);

      if (tileX < 0 || tileX >= 5 || tileY < 0 || tileY >= 5) return;

      if (!copiedTileData) {
        // First click - copy the tile
        copyTile(tileX, tileY);
        selectedTileX = tileX;
        selectedTileY = tileY;
        highlightTile(tileX, tileY);
        showSuccess(`Copied tile (${tileX}, ${tileY}). Click another tile to paste.`);
      } else {
        // Second click - paste to the tile
        pasteTile(tileX, tileY);
        showSuccess(`Pasted to tile (${tileX}, ${tileY})`);
        copiedTileData = null;
        selectedTileX = -1;
        selectedTileY = -1;
        drawGrid(); // Remove highlight
      }
    });

    function copyTile(tileX, tileY) {
      if (!pixelEditor) return;

      const pixelData = pixelEditor.getData();
      copiedTileData = [];

      // Copy 16√ó16 pixels starting from tile position
      const startX = tileX * 16;
      const startY = tileY * 16;

      for (let y = 0; y < 16; y++) {
        copiedTileData[y] = [];
        for (let x = 0; x < 16; x++) {
          const sourceY = startY + y;
          const sourceX = startX + x;
          if (sourceY < pixelData.pixels.length && sourceX < pixelData.pixels[0].length) {
            copiedTileData[y][x] = pixelData.pixels[sourceY][sourceX];
          } else {
            copiedTileData[y][x] = 'transparent';
          }
        }
      }
    }

    function pasteTile(tileX, tileY) {
      if (!pixelEditor || !copiedTileData) return;

      const startX = tileX * 16;
      const startY = tileY * 16;

      // Paste 16√ó16 pixels to pixel editor
      for (let y = 0; y < 16; y++) {
        for (let x = 0; x < 16; x++) {
          const destY = startY + y;
          const destX = startX + x;
          if (destY < 80 && destX < 80) {
            pixelEditor.pixelData[destY][destX] = copiedTileData[y][x];
          }
        }
      }

      // Re-render the pixel editor
      pixelEditor.render();

      // Update preview
      updatePreviewFromEditor();
    }

    function highlightTile(tileX, tileY) {
      // Redraw grid with highlight
      drawGrid();

      // Draw highlight rectangle
      gridCtx.strokeStyle = '#00ff88';
      gridCtx.lineWidth = 4;
      gridCtx.strokeRect(tileX * 128, tileY * 128, 128, 128);
    }

    function cancelCopy() {
      copiedTileData = null;
      selectedTileX = -1;
      selectedTileY = -1;
      drawGrid(); // Remove highlight
      showSuccess('Copy cancelled');
    }

    // Hitbox layer functions
    function setupHitboxDrawing() {
      hitboxCanvas.addEventListener('mousedown', startHitboxDraw);
      hitboxCanvas.addEventListener('mousemove', drawHitbox);
      hitboxCanvas.addEventListener('mouseup', endHitboxDraw);
    }

    function startHitboxDraw(e) {
      if (currentLayer !== 'hitbox') return;
      isDrawingHitbox = true;
      const rect = hitboxCanvas.getBoundingClientRect();
      const scaleX = 80 / rect.width;
      const scaleY = 80 / rect.height;
      hitboxStartX = Math.floor((e.clientX - rect.left) * scaleX);
      hitboxStartY = Math.floor((e.clientY - rect.top) * scaleY);
    }

    function drawHitbox(e) {
      if (!isDrawingHitbox || currentLayer !== 'hitbox') return;
      const rect = hitboxCanvas.getBoundingClientRect();
      const scaleX = 80 / rect.width;
      const scaleY = 80 / rect.height;
      const currentX = Math.floor((e.clientX - rect.left) * scaleX);
      const currentY = Math.floor((e.clientY - rect.top) * scaleY);

      // Redraw all existing hitboxes
      renderHitboxes();

      // Draw current hitbox being created
      hitboxCtx.strokeStyle = '#ff4f4f';
      hitboxCtx.fillStyle = 'rgba(255, 79, 79, 0.3)';
      hitboxCtx.lineWidth = 1;
      const width = currentX - hitboxStartX;
      const height = currentY - hitboxStartY;
      hitboxCtx.fillRect(hitboxStartX, hitboxStartY, width, height);
      hitboxCtx.strokeRect(hitboxStartX, hitboxStartY, width, height);
    }

    function endHitboxDraw(e) {
      if (!isDrawingHitbox || currentLayer !== 'hitbox') return;
      isDrawingHitbox = false;
      const rect = hitboxCanvas.getBoundingClientRect();
      const scaleX = 80 / rect.width;
      const scaleY = 80 / rect.height;
      const endX = Math.floor((e.clientX - rect.left) * scaleX);
      const endY = Math.floor((e.clientY - rect.top) * scaleY);

      // Determine which tile this hitbox belongs to
      const tileX = Math.floor(hitboxStartX / 16);
      const tileY = Math.floor(hitboxStartY / 16);
      const tileIndex = tileY * 5 + tileX;

      // Store hitbox data
      if (!hitboxData[tileIndex]) {
        hitboxData[tileIndex] = [];
      }

      hitboxData[tileIndex].push({
        x: hitboxStartX,
        y: hitboxStartY,
        width: endX - hitboxStartX,
        height: endY - hitboxStartY
      });

      renderHitboxes();
      showSuccess(`Hitbox added to tile ${tileIndex} (${tileX}, ${tileY})`);
    }

    function renderHitboxes() {
      if (!hitboxVisible) return;
      hitboxCtx.clearRect(0, 0, 80, 80);

      Object.keys(hitboxData).forEach(tileIndex => {
        hitboxData[tileIndex].forEach(box => {
          hitboxCtx.strokeStyle = '#ff4f4f';
          hitboxCtx.fillStyle = 'rgba(255, 79, 79, 0.3)';
          hitboxCtx.lineWidth = 1;
          hitboxCtx.fillRect(box.x, box.y, box.width, box.height);
          hitboxCtx.strokeRect(box.x, box.y, box.width, box.height);
        });
      });
    }

    function clearHitboxLayer() {
      if (confirm('Clear all hitboxes? This cannot be undone.')) {
        hitboxData = {};
        hitboxCtx.clearRect(0, 0, 80, 80);
        showSuccess('All hitboxes cleared');
      }
    }

    function toggleHitboxVisibility() {
      hitboxVisible = !hitboxVisible;
      if (hitboxVisible) {
        renderHitboxes();
        showSuccess('Hitboxes visible');
      } else {
        hitboxCtx.clearRect(0, 0, 80, 80);
        showSuccess('Hitboxes hidden');
      }
    }

    function exportHitboxData() {
      const hitboxJson = JSON.stringify(hitboxData, null, 2);
      const blob = new Blob([hitboxJson], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'hitbox-data.json';
      a.click();
      URL.revokeObjectURL(url);
      showSuccess('Hitbox data exported!');
    }

    // Initialize on load
    init();
    setupHitboxDrawing();
  </script>
</body>
</html>
