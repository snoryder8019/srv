<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title><%= title %></title>
  <link rel="stylesheet" href="/stylesheets/style.css">
  <link rel="stylesheet" href="/stylesheets/galactic-map.css">
  <% if (user && user.userRole === 'tester') { %>
  <link rel="stylesheet" href="/stylesheets/tester-toolbar.css">
  <link rel="stylesheet" href="/stylesheets/global-chat.css">
  <link rel="stylesheet" href="/stylesheets/ship-info-pane.css">
  <% } %>
  <style>
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    .sync-connected { background: #4ade80 !important; border-color: #4ade80 !important; }
    .sync-error { background: #ef4444 !important; border-color: #ef4444 !important; box-shadow: 0 0 8px #ef4444 !important; }
    .sync-warning { background: #f59e0b !important; border-color: #f59e0b !important; box-shadow: 0 0 8px #f59e0b !important; }
  </style>
</head>
<body>
  <%- include('../partials/header', { user: user }) %>

  <div class="map-container">
    <!-- Main Canvas Map -->
    <div class="map-canvas-wrapper">
      <canvas id="galacticMap"></canvas>
    </div>

    <!-- Project Title -->
    <div class="project-title-overlay">
      <h1 class="project-title">Project Stringborne</h1>
      <div class="project-subtitle">Galactic Map</div>
    </div>

    <!-- Sync Indicator moved inside Tester Debug Panel -->

    <!-- Sync indicator styles moved to tester-toolbar.js inline styles -->

    <!-- Map Controls -->
    <div class="map-controls">
      <!-- Menu Toggle -->
      <div class="control-group">
        <button id="toggleMenuBtn" class="control-btn menu-btn" title="Toggle Menu">‚ò∞</button>
      </div>

      <!-- Zoom Controls -->
      <div class="control-group zoom-controls">
        <button id="zoomInBtn" class="control-btn zoom-btn" title="Zoom In">+</button>
        <button id="zoomOutBtn" class="control-btn zoom-btn" title="Zoom Out">‚àí</button>
        <button id="resetViewBtn" class="control-btn zoom-btn" title="Reset View">‚ü≤</button>
        <% if (user) { %>
        <button id="goToMeBtn" class="control-btn zoom-btn" title="Go to My Character">üìç</button>
        <% } %>
      </div>

      <!-- View Controls -->
      <div class="control-group">
        <button id="toggleGridBtn" class="control-btn" title="Toggle Grid">‚äû</button>
        <button id="toggleRoutesBtn" class="control-btn" title="Toggle Travel Routes" style="background: rgba(102, 126, 234, 0.3);">üõ§Ô∏è</button>
      </div>

      <% if (user && user.isAdmin) { %>
      <!-- Admin Control Toggle -->
      <div class="control-group">
        <button id="toggleAdminBtn" class="control-btn" title="Toggle Admin Controls">‚öôÔ∏è</button>
      </div>
      <% } %>
    </div>

    <!-- Overlay Menu System -->
    <div class="overlay-menu" id="overlayMenu">
      <div class="overlay-menu-header">
        <h2 class="overlay-menu-title">Navigation Hub</h2>
        <button class="overlay-menu-close" onclick="toggleOverlayMenu()">‚úï</button>
      </div>

      <nav class="overlay-menu-nav">
        <div class="overlay-menu-item" onclick="openPWAModal('charactersModal')">
          <span class="menu-item-icon">‚öîÔ∏è</span>
          <span class="menu-item-label">Characters</span>
          <span class="menu-item-arrow">‚Ä∫</span>
        </div>

        <div class="overlay-menu-item" onclick="openPWAModal('tomeModal')">
          <span class="menu-item-icon">üìñ</span>
          <span class="menu-item-label">The Tome</span>
          <span class="menu-item-arrow">‚Ä∫</span>
        </div>

        <div class="overlay-menu-item" onclick="openPWAModal('workshopModal')">
          <span class="menu-item-icon">üé®</span>
          <span class="menu-item-label">Asset Workshop</span>
          <span class="menu-item-arrow">‚Ä∫</span>
        </div>

        <div class="overlay-menu-item" onclick="openPWAModal('votingModal')">
          <span class="menu-item-icon">üó≥Ô∏è</span>
          <span class="menu-item-label">Asset Governance</span>
          <span class="menu-item-arrow">‚Ä∫</span>
        </div>

        <!-- Inventory removed - API endpoint, needs proper view page
        <div class="overlay-menu-item" onclick="openPWAModal('inventoryModal')">
          <span class="menu-item-icon">üéí</span>
          <span class="menu-item-label">Inventory</span>
          <span class="menu-item-arrow">‚Ä∫</span>
        </div>
        -->

        <div class="overlay-menu-item" onclick="openPWAModal('profileModal')">
          <span class="menu-item-icon">üìä</span>
          <span class="menu-item-label">Profile</span>
          <span class="menu-item-arrow">‚Ä∫</span>
        </div>

        <div class="overlay-menu-divider"></div>

        <a href="/menu" class="overlay-menu-item">
          <span class="menu-item-icon">üè†</span>
          <span class="menu-item-label">Exit to Menu</span>
          <span class="menu-item-arrow">‚Ä∫</span>
        </a>

        <% if (user && user.isAdmin) { %>
        <div class="overlay-menu-divider"></div>
        <div class="overlay-menu-section-title">Admin</div>

        <div class="overlay-menu-item admin-item" onclick="openPWAModal('adminModal')">
          <span class="menu-item-icon">‚öôÔ∏è</span>
          <span class="menu-item-label">Admin Dashboard</span>
          <span class="menu-item-arrow">‚Ä∫</span>
        </div>
        <% } %>
      </nav>
    </div>

    <!-- Overlay backdrop -->
    <div class="overlay-backdrop" id="overlayBackdrop" onclick="toggleOverlayMenu()"></div>

    <!-- PWA Modal Container -->
    <div class="pwa-modal" id="pwaModalContainer">
      <div class="pwa-modal-header">
        <button class="pwa-modal-back" onclick="closePWAModal()">‚Üê Back</button>
        <h2 class="pwa-modal-title" id="pwaModalTitle">Loading...</h2>
        <button class="pwa-modal-close" onclick="closePWAModal()">‚úï</button>
      </div>
      <div class="pwa-modal-content" id="pwaModalContent">
        <div class="pwa-modal-loading">
          <div class="loading-spinner"></div>
          <p>Loading...</p>
        </div>
      </div>
    </div>

    <% if (user && user.isAdmin) { %>
    <!-- Admin Controls Panel -->
    <div class="controls-panel" id="adminControlsPanel" style="display: none;">
      <div class="controls-header">
        <h3>‚öôÔ∏è Admin Controls</h3>
        <button class="close-controls-btn" onclick="toggleAdminPanel()">‚úï</button>
      </div>
      <div class="controls-content">
        <!-- State Manager Section -->
        <div class="control-section-header">
          <h4>üîß State Manager</h4>
        </div>

        <div class="control-section">
          <label for="movementSpeedSlider">
            Movement Speed: <span id="movementSpeedValue">0.1</span>x
          </label>
          <input type="range" id="movementSpeedSlider" min="0" max="5" step="0.1" value="0.1">
          <div class="speed-presets">
            <button onclick="setMovementSpeed(0)" class="preset-btn">Pause</button>
            <button onclick="setMovementSpeed(0.1)" class="preset-btn">0.1x</button>
            <button onclick="setMovementSpeed(0.5)" class="preset-btn">0.5x</button>
            <button onclick="setMovementSpeed(1)" class="preset-btn">1x</button>
            <button onclick="setMovementSpeed(2)" class="preset-btn">2x</button>
            <button onclick="setMovementSpeed(5)" class="preset-btn">5x</button>
          </div>
        </div>

        <div class="control-section">
          <label for="gridSizeSlider">
            Grid Size: <span id="gridSizeValue">100</span>
          </label>
          <input type="range" id="gridSizeSlider" min="50" max="500" step="50" value="100">
        </div>

        <div class="control-section">
          <label for="edgeGravitySlider">
            Edge Gravity: <span id="edgeGravityValue">0.15</span>
          </label>
          <input type="range" id="edgeGravitySlider" min="0" max="1" step="0.05" value="0.15">
        </div>

        <div class="control-section">
          <label for="brownNoiseSlider">
            Brown Noise: <span id="brownNoiseValue">0.05</span>
          </label>
          <input type="range" id="brownNoiseSlider" min="0" max="0.5" step="0.01" value="0.05">
          <label class="checkbox-label">
            <input type="checkbox" id="brownNoiseEnabled" checked>
            Enable Brown Noise
          </label>
        </div>

        <div class="control-section">
          <button id="saveSettingsBtn" class="save-btn">üíæ Save Settings</button>
          <button id="resetSettingsBtn" class="reset-btn">üîÑ Reset to Default</button>
        </div>

        <div class="control-section">
          <div class="settings-status" id="settingsStatus"></div>
        </div>

        <!-- Debugger Section -->
        <div class="control-section-header">
          <h4>üêõ Debugger</h4>
        </div>

        <div class="control-section">
          <div class="debug-info-panel">
            <div class="debug-item">
              <span class="debug-label">Game State Sync:</span>
              <span class="debug-value" id="debugGameStateSync">Checking...</span>
            </div>
            <div class="debug-item">
              <span class="debug-label">Assets Loaded:</span>
              <span class="debug-value" id="debugAssetsCount">0</span>
            </div>
            <div class="debug-item">
              <span class="debug-label">Characters Online:</span>
              <span class="debug-value" id="debugCharactersCount">0</span>
            </div>
            <div class="debug-item">
              <span class="debug-label">Physics FPS:</span>
              <span class="debug-value" id="debugFPS">30</span>
            </div>
            <div class="debug-item">
              <span class="debug-label">Travel Routes:</span>
              <span class="debug-value" id="debugRoutesCount">0</span>
            </div>
            <div class="debug-item">
              <span class="debug-label">Last Sync:</span>
              <span class="debug-value" id="debugLastSync">Never</span>
            </div>
          </div>
          <button id="forceStateSync" class="preset-btn" style="width: 100%; margin-top: 0.5rem;">üîÑ Force State Sync</button>
        </div>
      </div>
    </div>
    <% } %>

    <!-- Selection Menu for Overlapping Assets -->
    <div class="asset-selection-menu" id="assetSelectionMenu" style="display: none;">
      <div class="selection-menu-header">
        <h3>Select Asset</h3>
        <button class="close-menu-btn" onclick="closeSelectionMenu()">‚úï</button>
      </div>
      <div class="selection-menu-list" id="assetSelectionList">
        <!-- Populated by JavaScript -->
      </div>
    </div>

    <!-- Side Panel - Info Pane (Hidden by default, shows on asset click) -->
    <div class="side-panel" id="infoPane">
      <button class="panel-close-btn" onclick="document.getElementById('infoPane').classList.remove('visible')">‚úï</button>
      <div class="panel-section">
        <div id="assetInfo"></div>
      </div>
    </div>
  </div>

  <%- include('../partials/footer') %>

  <script src="/socket.io/socket.io.js"></script>
  <% if (user && user.userRole === 'tester') { %>
  <script src="/javascripts/tester-toolbar.js"></script>
  <script src="/javascripts/global-chat.js"></script>
  <script src="/javascripts/ship-info-pane.js"></script>
  <% } %>

  <script type="module">
    import GalacticMap from '/javascripts/galactic-map-optimized.js?v=1.2';

    let map = null;

    // Parse galaxies data from server
    const galaxiesData = <%- galaxies %>;
    console.log('üì° Loaded galaxies from database:', galaxiesData);

    // Initialize map
    document.addEventListener('DOMContentLoaded', async () => {
      map = new GalacticMap('galacticMap', 5000, 5000); // Match actual map size

      // Expose map globally for console access
      window.galacticMap = map;

      // Load galaxies as static points on the map
      if (galaxiesData && galaxiesData.length > 0) {
        console.log('üåå Adding', galaxiesData.length, 'galaxies to map');

        // Transform galaxies to map asset format
        const galaxyAssets = galaxiesData.map(galaxy => ({
          ...galaxy,
          x: galaxy.coordinates?.x || Math.random() * 5000,
          y: galaxy.coordinates?.y || Math.random() * 5000,
          vx: 0, // Galaxies are stationary
          vy: 0,
          radius: 30, // Larger size for galaxies
          mass: 10,
          isStationary: true,
          assetType: 'galaxy'
        }));

        // Add galaxies to the map's published assets
        map.publishedAssets = [...(map.publishedAssets || []), ...galaxyAssets];
        console.log('‚úÖ Galaxies added to map:', map.publishedAssets.length, 'total assets');
      }

      // Get URL parameters
      const urlParams = new URLSearchParams(window.location.search);
      let characterId = urlParams.get('character');
      const randomize = urlParams.get('randomize');

      // If no character in URL, check localStorage
      if (!characterId) {
        characterId = localStorage.getItem('selectedCharacterId');
        console.log('No character in URL, checking localStorage:', characterId);
      }

      if (characterId) {
        console.log('Loading character:', characterId);
        try {
          // Load character from API
          const response = await fetch(`/api/v1/characters/${characterId}`);
          const data = await response.json();
          if (data.character) {
            map.currentCharacter = data.character;
            console.log('Character loaded:', data.character.name, 'at', data.character.location);

            // Save to localStorage for persistence across navigation
            localStorage.setItem('selectedCharacterId', characterId);

            // Center view on character
            if (data.character.location) {
              map.offsetX = -data.character.location.x * map.scale + map.canvas.width / 2;
              map.offsetY = -data.character.location.y * map.scale + map.canvas.height / 2;
            }
          }
        } catch (error) {
          console.error('Failed to load character:', error);
          // Clear invalid character from localStorage
          localStorage.removeItem('selectedCharacterId');
          // Show helpful message
          showNoCharacterMessage();
        }
      } else {
        // No character found - show helpful message
        showNoCharacterMessage();
      }

      /**
       * Show message when no character is found
       */
      function showNoCharacterMessage() {
        <% if (user) { %>
        // User is logged in but has no character
        const notification = document.createElement('div');
        notification.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: rgba(17, 24, 39, 0.95);
          border: 2px solid #667eea;
          border-radius: 12px;
          padding: 2rem;
          max-width: 500px;
          z-index: 10000;
          text-align: center;
          box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        `;
        notification.innerHTML = `
          <div style="font-size: 3rem; margin-bottom: 1rem;">üöÄ</div>
          <h2 style="margin: 0 0 1rem 0; color: #ffffff; font-size: 1.5rem;">No Character Found</h2>
          <p style="margin: 0 0 1.5rem 0; color: #d1d5db; line-height: 1.6;">
            You need to create a character before exploring the galactic map.
          </p>
          <div style="display: flex; gap: 1rem; justify-content: center;">
            <a href="/characters/create" style="
              padding: 0.75rem 1.5rem;
              background: linear-gradient(135deg, #667eea, #764ba2);
              color: white;
              text-decoration: none;
              border-radius: 0.5rem;
              font-weight: 600;
              transition: transform 0.2s;
            " onmouseover="this.style.transform='translateY(-2px)'" onmouseout="this.style.transform='translateY(0)'">
              Create Character
            </a>
            <a href="/characters" style="
              padding: 0.75rem 1.5rem;
              background: rgba(255, 255, 255, 0.1);
              color: white;
              text-decoration: none;
              border-radius: 0.5rem;
              font-weight: 600;
              border: 1px solid rgba(255, 255, 255, 0.2);
              transition: transform 0.2s;
            " onmouseover="this.style.transform='translateY(-2px)'" onmouseout="this.style.transform='translateY(0)'">
              My Characters
            </a>
          </div>
        `;
        document.body.appendChild(notification);
        <% } else { %>
        // User is not logged in
        const notification = document.createElement('div');
        notification.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: rgba(17, 24, 39, 0.95);
          border: 2px solid #667eea;
          border-radius: 12px;
          padding: 2rem;
          max-width: 500px;
          z-index: 10000;
          text-align: center;
          box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        `;
        notification.innerHTML = `
          <div style="font-size: 3rem; margin-bottom: 1rem;">üîê</div>
          <h2 style="margin: 0 0 1rem 0; color: #ffffff; font-size: 1.5rem;">Login Required</h2>
          <p style="margin: 0 0 1.5rem 0; color: #d1d5db; line-height: 1.6;">
            Please log in to create a character and explore the galactic map.
          </p>
          <a href="/auth" style="
            display: inline-block;
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            text-decoration: none;
            border-radius: 0.5rem;
            font-weight: 600;
            transition: transform 0.2s;
          " onmouseover="this.style.transform='translateY(-2px)'" onmouseout="this.style.transform='translateY(0)'">
            Login / Register
          </a>
        `;
        document.body.appendChild(notification);
        <% } %>
      }

      // Set asset selection callback - now handles multiple overlapping assets
      map.onAssetSelect = (assetOrAssets, x, y) => {
        // Check if we received an array of assets (multiple overlapping)
        if (Array.isArray(assetOrAssets) && assetOrAssets.length > 1) {
          showAssetSelectionMenu(assetOrAssets, x, y);
        } else {
          // Single asset
          const asset = Array.isArray(assetOrAssets) ? assetOrAssets[0] : assetOrAssets;
          window.displayAssetInfo(asset);
          window.closeSelectionMenu();
        }
      };

      // Check if randomize parameter is set
      if (randomize === 'true' || randomize === '1') {
        console.log('üé≤ Randomization requested via URL parameter');
        await map.randomizeAllPositions();
        // Remove randomize parameter from URL
        urlParams.delete('randomize');
        const newUrl = window.location.pathname + (urlParams.toString() ? '?' + urlParams.toString() : '');
        window.history.replaceState({}, '', newUrl);
      }

      // Start map animation
      map.start();

      // Save character position before page unload
      window.addEventListener('beforeunload', () => {
        if (map && map.currentCharacter) {
          // Use sendBeacon for reliable async save during page unload
          const data = JSON.stringify({
            x: map.currentCharacter.location.x,
            y: map.currentCharacter.location.y,
            type: map.currentCharacter.location.type || 'galactic',
            zone: map.currentCharacter.location.zone,
            assetId: map.currentCharacter.location.assetId
          });

          navigator.sendBeacon(
            `/api/v1/characters/${map.currentCharacter._id}/location`,
            new Blob([data], { type: 'application/json' })
          );

          console.log('üìç Character position saved on page unload');
        }
      });

      // Setup controls
      setupControls();

      <% if (user && user.userRole === 'tester') { %>
      // Setup sync indicator (only for testers - elements are in tester toolbar)
      setupSyncIndicator();
      <% } %>

      <% if (user && user.userRole === 'tester') { %>
      // Initialize Socket.IO for testers
      const socket = io({
        reconnection: true,
        reconnectionDelay: 1000,
        reconnectionDelayMax: 5000,
        reconnectionAttempts: 10
      });

      // Initialize tester components
      const userObj = {
        _id: '<%= user._id %>',
        id: '<%= user._id %>',
        username: '<%= user.username %>',
        userRole: '<%= user.userRole %>'
      };

      // Handle connection errors
      socket.on('connect_error', (error) => {
        console.error('‚ùå Socket.IO connection error:', error);
        console.log('Retrying connection...');
      });

      socket.on('disconnect', (reason) => {
        console.warn('‚ö†Ô∏è Socket.IO disconnected:', reason);
        if (window.testerToolbar) {
          window.testerToolbar.updateDebugInfo({ socketStatus: false });
        }
      });

      socket.on('reconnect', (attemptNumber) => {
        console.log('üîÑ Socket.IO reconnected after', attemptNumber, 'attempts');
        if (window.testerToolbar) {
          window.testerToolbar.updateDebugInfo({ socketStatus: true });
        }
      });

      socket.on('reconnect_failed', () => {
        console.error('‚ùå Socket.IO reconnection failed after all attempts');
      });

      // Initialize tester toolbar immediately (don't wait for socket)
      if (typeof TesterToolbar !== 'undefined') {
        // Character might not be loaded yet, pass map's currentCharacter (might be undefined)
        window.testerToolbar = new TesterToolbar(userObj, map.currentCharacter);
        // Connect to map for real-time updates
        window.testerToolbar.connectMap(map);
      }

      // Wait for Socket.IO to connect before connecting socket to components
      socket.on('connect', () => {
        console.log('‚úÖ Socket.IO connected:', socket.id);

        // Get current character from map
        const characterObj = map.currentCharacter;

        // Connect tester toolbar to socket once connected
        if (window.testerToolbar) {
          window.testerToolbar.connectSocket(socket);
          window.testerToolbar.updateDebugInfo({ socketStatus: true });
        }

        // Initialize global chat
        if (typeof initGlobalChat !== 'undefined') {
          window.globalChat = initGlobalChat(socket, userObj, characterObj);
        }

        // Initialize ship info pane
        if (typeof ShipInfoPane !== 'undefined') {
          window.shipInfoPane = new ShipInfoPane(socket);
        }

        // Emit character join event to Socket.IO
        if (characterObj && characterObj.location) {
          console.log('üì° Emitting characterJoin:', characterObj.name, characterObj.location);
          socket.emit('characterJoin', {
            characterId: characterObj._id,
            characterName: characterObj.name,
            userId: userObj._id,
            location: characterObj.location,
            assetId: characterObj.location.assetId || null,
            stringDomain: characterObj.stringDomain || 'Time String'
          });
        } else {
          console.warn('‚ö†Ô∏è Character or location missing:', characterObj);
        }
      });

      // Listen for other players' location updates
      socket.on('onlinePlayers', (players) => {
        console.log('üì° Received online players:', players.length, players);

        // Update map with all online players
        map.characters = players.map(p => ({
          characterId: p.characterId,
          name: p.characterName,
          location: p.location,
          stringDomain: p.stringDomain || 'Time String'
        }));

        console.log('‚úÖ Map characters updated:', map.characters.length, map.characters);
      });

      // Listen for player joins
      socket.on('characterJoined', (data) => {
        console.log('üë§ Player joined:', data.characterName);

        // Add to characters array
        if (!map.characters) map.characters = [];
        map.characters.push({
          characterId: data.characterId,
          name: data.characterName,
          location: data.location,
          stringDomain: data.stringDomain || 'Time String'
        });
      });

      // Listen for player leaves
      socket.on('characterLeft', (data) => {
        console.log('üë§ Player left:', data.characterName);

        // Remove from characters array
        if (map.characters) {
          map.characters = map.characters.filter(c => c.characterId !== data.characterId);
        }
      });

      // Listen for location updates
      socket.on('characterLocationUpdate', (data) => {
        console.log('üìç Character moved:', data.characterName, data.location);

        // Update character in array
        if (map.characters) {
          const char = map.characters.find(c => c.characterId === data.characterId);
          if (char) {
            char.location = data.location;
          }
        }
      });
      <% } %>


      // Close info pane when clicking/touching outside
      const closeInfoPaneOutside = (e) => {
        const infoPane = document.getElementById('infoPane');
        const controlsPanel = document.querySelector('.controls-panel');
        const canvas = document.getElementById('galacticMap');

        // Don't close if pane is not visible
        if (!infoPane.classList.contains('visible')) return;

        // Don't close if clicking on the info pane itself
        if (infoPane.contains(e.target)) return;

        // Don't close if clicking controls
        if (controlsPanel && controlsPanel.contains(e.target)) return;

        // Don't close if clicking canvas (canvas handles asset selection)
        if (canvas && e.target === canvas) return;

        // Close the info pane for clicks outside these areas
        infoPane.classList.remove('visible');
      };

      // Add both click and touch listeners
      document.addEventListener('click', closeInfoPaneOutside);
      document.addEventListener('touchend', closeInfoPaneOutside);
    });

    /**
     * Setup map controls
     */
    function setupControls() {
      // Zoom In
      document.getElementById('zoomInBtn').addEventListener('click', () => {
        map.scale = Math.min(map.scale * 1.2, 5); // Max 5x zoom for larger grid
      });

      // Zoom Out
      document.getElementById('zoomOutBtn').addEventListener('click', () => {
        map.scale = Math.max(map.scale / 1.2, 0.1); // Min 0.1x zoom for larger grid
      });

      // Reset View
      document.getElementById('resetViewBtn').addEventListener('click', () => {
        map.scale = 0.3; // Reset to default zoom for 5000x5000 grid
        map.offsetX = 0;
        map.offsetY = 0;
      });

      <% if (user) { %>
      // Go to Me - Center on current character
      const goToMeBtn = document.getElementById('goToMeBtn');
      if (goToMeBtn) {
        goToMeBtn.addEventListener('click', () => {
          if (map.currentCharacter && map.currentCharacter.location) {
            // Center view on character's position
            map.offsetX = -map.currentCharacter.location.x * map.scale + map.canvas.width / 2;
            map.offsetY = -map.currentCharacter.location.y * map.scale + map.canvas.height / 2;

            // Optional: Add a zoom level for better visibility
            map.scale = Math.max(0.5, map.scale);

            // Update offsets after zoom
            map.offsetX = -map.currentCharacter.location.x * map.scale + map.canvas.width / 2;
            map.offsetY = -map.currentCharacter.location.y * map.scale + map.canvas.height / 2;

            console.log('üìç Centered on character:', map.currentCharacter.name);
          } else {
            alert('No character location found');
          }
        });
      }
      <% } %>

      // Toggle Grid
      document.getElementById('toggleGridBtn').addEventListener('click', (e) => {
        map.showGrid = !map.showGrid;
        e.target.style.background = map.showGrid ?
          'rgba(102, 126, 234, 0.3)' :
          'rgba(255, 255, 255, 0.1)';
      });

      // Toggle Travel Routes
      document.getElementById('toggleRoutesBtn').addEventListener('click', (e) => {
        map.showConnections = !map.showConnections;
        e.target.style.background = map.showConnections ?
          'rgba(102, 126, 234, 0.3)' :
          'rgba(255, 255, 255, 0.1)';
      });

      <% if (user && user.isAdmin) { %>
      // Toggle Admin Panel
      const toggleAdminBtn = document.getElementById('toggleAdminBtn');
      if (toggleAdminBtn) {
        toggleAdminBtn.addEventListener('click', () => {
          toggleAdminPanel();
        });
      }

      // Load admin settings on page load
      loadAdminSettings();

      // Setup admin control handlers
      setupAdminControls();
      <% } %>
    }

    /**
     * Toggle Overlay Menu
     */
    window.toggleOverlayMenu = function() {
      const menu = document.getElementById('overlayMenu');
      const backdrop = document.getElementById('overlayBackdrop');
      const btn = document.getElementById('toggleMenuBtn');

      const isActive = menu.classList.contains('active');

      if (isActive) {
        menu.classList.remove('active');
        backdrop.classList.remove('active');
        if (btn) btn.classList.remove('active');
      } else {
        menu.classList.add('active');
        backdrop.classList.add('active');
        if (btn) btn.classList.add('active');
      }
    };

    // Add menu toggle button listener
    document.addEventListener('DOMContentLoaded', () => {
      const toggleMenuBtn = document.getElementById('toggleMenuBtn');
      if (toggleMenuBtn) {
        toggleMenuBtn.addEventListener('click', toggleOverlayMenu);
      }

      // Close menu on ESC key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          const modal = document.getElementById('pwaModalContainer');
          if (modal && modal.classList.contains('active')) {
            closePWAModal();
            return;
          }

          const menu = document.getElementById('overlayMenu');
          if (menu && menu.classList.contains('active')) {
            toggleOverlayMenu();
          }
        }
      });
    });

    /**
     * PWA Modal System - Opens content in full-screen modal over the map
     */
    const modalRoutes = {
      charactersModal: { url: '/characters', title: 'Characters' },
      tomeModal: { url: '/universe/tome', title: 'The Tome' },
      workshopModal: { url: '/assets', title: 'Asset Workshop' },
      votingModal: { url: '/assets/voting', title: 'Asset Governance' },
      // inventoryModal: { url: '/api/v1/inventory/character', title: 'Inventory' }, // API endpoint, not a page
      profileModal: { url: '/profile', title: 'Profile' },
      adminModal: { url: '/admin', title: 'Admin Dashboard' }
    };

    window.openPWAModal = async function(modalId) {
      const modal = document.getElementById('pwaModalContainer');
      const titleEl = document.getElementById('pwaModalTitle');
      const contentEl = document.getElementById('pwaModalContent');

      const route = modalRoutes[modalId];
      if (!route) {
        console.error('Unknown modal:', modalId);
        return;
      }

      // Close overlay menu if open
      toggleOverlayMenu();

      // Show modal with loading state
      modal.classList.add('active');
      titleEl.textContent = route.title;
      contentEl.innerHTML = '<div class="pwa-modal-loading"><div class="loading-spinner"></div><p>Loading...</p></div>';

      try {
        // Fetch content
        const response = await fetch(route.url);
        if (!response.ok) throw new Error('Failed to load content');

        const html = await response.text();

        // Extract body content (strip header/footer)
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        const main = doc.querySelector('main') || doc.querySelector('.container') || doc.body;

        // Inject content
        contentEl.innerHTML = main.innerHTML;

        // Execute any scripts in the loaded content
        const scripts = contentEl.querySelectorAll('script');
        scripts.forEach(script => {
          const newScript = document.createElement('script');
          if (script.src) {
            newScript.src = script.src;
          } else {
            newScript.textContent = script.textContent;
          }
          document.body.appendChild(newScript);
        });

        // Initialize modal functionality for nested modals after a short delay
        setTimeout(() => {
          initializeNestedModals();
        }, 100);

      } catch (error) {
        console.error('Error loading modal content:', error);
        contentEl.innerHTML = `
          <div class="pwa-modal-error">
            <div class="error-icon">‚ö†Ô∏è</div>
            <h3>Failed to Load</h3>
            <p>Unable to load ${route.title}. Please try again.</p>
            <button class="btn btn-primary" onclick="openPWAModal('${modalId}')">Retry</button>
          </div>
        `;
      }
    };

    window.closePWAModal = function() {
      const modal = document.getElementById('pwaModalContainer');

      // Add closing animation class
      modal.classList.add('closing');
      modal.classList.remove('active');

      // Wait for closing animation to complete
      setTimeout(() => {
        modal.classList.remove('closing');
        // Clear content
        document.getElementById('pwaModalContent').innerHTML = '<div class="pwa-modal-loading"><div class="loading-spinner"></div><p>Loading...</p></div>';
      }, 400); // Match hudShutdown animation duration
    };

    /**
     * Open a nested modal by ID
     */
    window.openNestedModal = function(modalId) {
      const modal = document.getElementById(modalId) || document.querySelector(`[data-modal-id="${modalId}"]`);

      if (modal) {
        modal.style.display = 'flex';
        modal.classList.add('active');

        // Create backdrop if it doesn't exist
        let backdrop = modal.previousElementSibling;
        if (!backdrop || !backdrop.classList.contains('modal-backdrop')) {
          backdrop = document.createElement('div');
          backdrop.className = 'modal-backdrop';
          backdrop.addEventListener('click', () => window.closeNestedModal(modal));
          modal.parentNode.insertBefore(backdrop, modal);
        }
        backdrop.style.display = 'block';
      } else {
        console.error('Modal not found:', modalId);
      }
    };

    /**
     * Close a nested modal
     */
    window.closeNestedModal = function(modal) {
      if (!modal) return;

      modal.style.display = 'none';
      modal.classList.remove('active');

      // Remove backdrop
      const backdrop = modal.previousElementSibling;
      if (backdrop && backdrop.classList.contains('modal-backdrop')) {
        backdrop.style.display = 'none';
      }
    };

    /**
     * Initialize nested modal functionality
     * This makes modals work within the PWA modal content
     */
    function initializeNestedModals() {
      try {
        const contentEl = document.getElementById('pwaModalContent');
        if (!contentEl) return;

        // Setup close buttons for all modals in content
        const closeButtons = contentEl.querySelectorAll('.modal-close, .close-modal, [data-dismiss="modal"]');
        closeButtons.forEach(btn => {
          btn.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            const modal = this.closest('.modal');
            if (modal) window.closeNestedModal(modal);
          });
        });

        // Click outside to close
        const modals = contentEl.querySelectorAll('.modal');
        modals.forEach(modal => {
          modal.addEventListener('click', function(e) {
            if (e.target === this) {
              window.closeNestedModal(this);
            }
          });
        });
      } catch (error) {
        console.error('Error initializing nested modals:', error);
      }
    }

    <% if (user && user.isAdmin) { %>
    /**
     * Toggle admin control panel
     */
    window.toggleAdminPanel = function() {
      const panel = document.getElementById('adminControlsPanel');
      const btn = document.getElementById('toggleAdminBtn');
      if (panel.style.display === 'none') {
        panel.style.display = 'block';
        if (btn) btn.style.background = 'rgba(102, 126, 234, 0.3)';
      } else {
        panel.style.display = 'none';
        if (btn) btn.style.background = 'rgba(255, 255, 255, 0.1)';
      }
    };

    /**
     * Load admin settings from server
     */
    async function loadAdminSettings() {
      try {
        const response = await fetch('/admin/api/galactic-map/settings');
        if (!response.ok) {
          console.error('Failed to load admin settings');
          return;
        }

        const data = await response.json();
        if (data.success && data.settings) {
          const s = data.settings;

          // Update sliders and values
          document.getElementById('movementSpeedSlider').value = s.movementSpeed || 0.1;
          document.getElementById('movementSpeedValue').textContent = s.movementSpeed || 0.1;

          document.getElementById('gridSizeSlider').value = s.gridSize || 100;
          document.getElementById('gridSizeValue').textContent = s.gridSize || 100;

          document.getElementById('edgeGravitySlider').value = s.edgeGravityStrength || 0.15;
          document.getElementById('edgeGravityValue').textContent = s.edgeGravityStrength || 0.15;

          document.getElementById('brownNoiseSlider').value = s.brownNoiseStrength || 0.05;
          document.getElementById('brownNoiseValue').textContent = s.brownNoiseStrength || 0.05;

          document.getElementById('brownNoiseEnabled').checked = s.brownNoiseEnabled !== false;

          // Apply settings to map immediately
          if (map) {
            map.movementSpeed = s.movementSpeed || 0.1;
            map.gridSize = s.gridSize || 100;
            map.edgeGravityStrength = s.edgeGravityStrength || 0.15;
            map.edgeGravityDistance = s.edgeGravityDistance || 400;
            map.brownNoiseStrength = s.brownNoiseStrength || 0.05;
            map.brownNoiseEnabled = s.brownNoiseEnabled !== false;
            map.damping = s.damping || 0.999;
            map.maxVelocity = s.maxVelocity || 8;
          }
        }
      } catch (error) {
        console.error('Error loading admin settings:', error);
      }
    }

    /**
     * Setup admin control handlers
     */
    function setupAdminControls() {
      // Movement speed slider
      const movementSlider = document.getElementById('movementSpeedSlider');
      const movementValue = document.getElementById('movementSpeedValue');
      movementSlider.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        movementValue.textContent = value.toFixed(1);
        if (map) map.movementSpeed = value;
      });

      // Grid size slider
      const gridSlider = document.getElementById('gridSizeSlider');
      const gridValue = document.getElementById('gridSizeValue');
      gridSlider.addEventListener('input', (e) => {
        const value = parseInt(e.target.value);
        gridValue.textContent = value;
        if (map) map.gridSize = value;
      });

      // Edge gravity slider
      const gravitySlider = document.getElementById('edgeGravitySlider');
      const gravityValue = document.getElementById('edgeGravityValue');
      gravitySlider.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        gravityValue.textContent = value.toFixed(2);
        if (map) map.edgeGravityStrength = value;
      });

      // Brown noise slider
      const noiseSlider = document.getElementById('brownNoiseSlider');
      const noiseValue = document.getElementById('brownNoiseValue');
      noiseSlider.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        noiseValue.textContent = value.toFixed(2);
        if (map) map.brownNoiseStrength = value;
      });

      // Brown noise enabled checkbox
      const noiseEnabled = document.getElementById('brownNoiseEnabled');
      noiseEnabled.addEventListener('change', (e) => {
        if (map) map.brownNoiseEnabled = e.target.checked;
      });

      // Save settings button
      document.getElementById('saveSettingsBtn').addEventListener('click', saveAdminSettings);

      // Reset settings button
      document.getElementById('resetSettingsBtn').addEventListener('click', resetAdminSettings);
    }

    /**
     * Set movement speed (for preset buttons)
     */
    window.setMovementSpeed = function(speed) {
      const slider = document.getElementById('movementSpeedSlider');
      const value = document.getElementById('movementSpeedValue');
      slider.value = speed;
      value.textContent = speed.toFixed(1);
      if (map) map.movementSpeed = speed;
    };

    /**
     * Save admin settings to server
     */
    async function saveAdminSettings() {
      const status = document.getElementById('settingsStatus');
      status.textContent = 'Saving...';
      status.className = 'settings-status saving';

      const settings = {
        movementSpeed: parseFloat(document.getElementById('movementSpeedSlider').value),
        gridSize: parseInt(document.getElementById('gridSizeSlider').value),
        edgeGravityStrength: parseFloat(document.getElementById('edgeGravitySlider').value),
        brownNoiseStrength: parseFloat(document.getElementById('brownNoiseSlider').value),
        brownNoiseEnabled: document.getElementById('brownNoiseEnabled').checked
      };

      try {
        const response = await fetch('/admin/api/galactic-map/settings', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(settings)
        });

        const data = await response.json();

        if (data.success) {
          status.textContent = '‚úì Settings saved successfully!';
          status.className = 'settings-status success';
          setTimeout(() => {
            status.textContent = '';
            status.className = 'settings-status';
          }, 3000);
        } else {
          status.textContent = '‚úó Failed to save settings: ' + (data.error || 'Unknown error');
          status.className = 'settings-status error';
        }
      } catch (error) {
        console.error('Error saving settings:', error);
        status.textContent = '‚úó Error saving settings: ' + error.message;
        status.className = 'settings-status error';
      }
    }

    /**
     * Reset settings to default
     */
    async function resetAdminSettings() {
      if (!confirm('Reset all settings to default values?')) return;

      const defaults = {
        movementSpeed: 1.0,
        gridSize: 100,
        edgeGravityStrength: 0.15,
        brownNoiseStrength: 0.05,
        brownNoiseEnabled: true
      };

      // Update UI
      document.getElementById('movementSpeedSlider').value = defaults.movementSpeed;
      document.getElementById('movementSpeedValue').textContent = defaults.movementSpeed;
      document.getElementById('gridSizeSlider').value = defaults.gridSize;
      document.getElementById('gridSizeValue').textContent = defaults.gridSize;
      document.getElementById('edgeGravitySlider').value = defaults.edgeGravityStrength;
      document.getElementById('edgeGravityValue').textContent = defaults.edgeGravityStrength;
      document.getElementById('brownNoiseSlider').value = defaults.brownNoiseStrength;
      document.getElementById('brownNoiseValue').textContent = defaults.brownNoiseStrength;
      document.getElementById('brownNoiseEnabled').checked = defaults.brownNoiseEnabled;

      // Apply to map
      if (map) {
        map.movementSpeed = defaults.movementSpeed;
        map.gridSize = defaults.gridSize;
        map.edgeGravityStrength = defaults.edgeGravityStrength;
        map.brownNoiseStrength = defaults.brownNoiseStrength;
        map.brownNoiseEnabled = defaults.brownNoiseEnabled;
      }

      // Save to server
      await saveAdminSettings();
    }
    <% } %>

    /**
     * Display asset info in hovering pane
     */
    window.displayAssetInfo = function(asset) {
      console.log('Displaying asset info for:', asset.title);

      const infoPane = document.getElementById('infoPane');
      const info = document.getElementById('assetInfo');

      // Show the pane
      infoPane.classList.add('visible');

      // Get icon based on asset type
      let icon = 'üåå';
      if (asset.assetType === 'galaxy') icon = 'üåå';
      else if (asset.assetType === 'orbital') icon = 'üõ∞Ô∏è';
      else if (asset.assetType === 'anomaly') icon = '‚ú®';
      if (asset.hubData?.isStartingLocation) icon = '‚≠ê';

      // Build position info
      const positionHTML = `
        <div class="info-section">
          <h4>üìç Position & Physics</h4>
          <div class="info-grid">
            <div class="info-item">
              <span class="info-label">X:</span>
              <span class="info-value">${Math.round(asset.x || 0)}</span>
            </div>
            <div class="info-item">
              <span class="info-label">Y:</span>
              <span class="info-value">${Math.round(asset.y || 0)}</span>
            </div>
            <div class="info-item">
              <span class="info-label">Velocity X:</span>
              <span class="info-value">${(asset.vx || 0).toFixed(3)}</span>
            </div>
            <div class="info-item">
              <span class="info-label">Velocity Y:</span>
              <span class="info-value">${(asset.vy || 0).toFixed(3)}</span>
            </div>
            <div class="info-item">
              <span class="info-label">Radius:</span>
              <span class="info-value">${Math.round(asset.radius || 10)}</span>
            </div>
            <div class="info-item">
              <span class="info-label">Mass:</span>
              <span class="info-value">${(asset.mass || 1).toFixed(2)}</span>
            </div>
            ${asset.staticCharge !== undefined ? `
              <div class="info-item">
                <span class="info-label">Static Charge:</span>
                <span class="info-value">${asset.staticCharge.toFixed(2)}</span>
              </div>
            ` : ''}
            <div class="info-item">
              <span class="info-label">Motion:</span>
              <span class="info-value">${asset.isStationary ? 'üî¥ Stationary' : 'üü¢ Moving'}</span>
            </div>
          </div>
        </div>
      `;

      // Build stats HTML
      let statsHTML = '';
      if (asset.stats && Object.keys(asset.stats).length > 0) {
        statsHTML = `
          <div class="info-section">
            <h4>üìä Statistics</h4>
            <div class="info-grid">
              ${Object.entries(asset.stats).map(([key, value]) => `
                <div class="info-item">
                  <span class="info-label">${key}:</span>
                  <span class="info-value">${value}</span>
                </div>
              `).join('')}
            </div>
          </div>
        `;
      }

      // Build effects HTML
      let effectsHTML = '';
      if (asset.effects && asset.effects.length > 0) {
        effectsHTML = `
          <div class="info-section">
            <h4>‚ú® Effects</h4>
            <div class="effects-list">
              ${asset.effects.map(effect => `
                <div class="effect-item">
                  <strong>${effect.type}</strong>
                  ${effect.description ? `<p>${effect.description}</p>` : ''}
                  ${effect.value ? `<span class="effect-value">Value: ${effect.value}</span>` : ''}
                  ${effect.stringDomain ? `<span class="effect-tag">${effect.stringDomain}</span>` : ''}
                </div>
              `).join('')}
            </div>
          </div>
        `;
      }

      // Build lore section
      let loreHTML = '';
      if (asset.lore || asset.backstory || asset.flavor) {
        loreHTML = `
          <div class="info-section">
            <h4>üìñ Lore</h4>
            ${asset.lore ? `<p class="lore-text">${asset.lore}</p>` : ''}
            ${asset.backstory ? `<p class="lore-text">${asset.backstory}</p>` : ''}
            ${asset.flavor ? `<p class="flavor-text">${asset.flavor}</p>` : ''}
          </div>
        `;
      }

      // Build hub data section
      let hubHTML = '';
      if (asset.hubData) {
        hubHTML = `
          <div class="info-section">
            <h4>üè† Hub Information</h4>
            <div class="info-grid">
              ${asset.hubData.stringDomain ? `
                <div class="info-item full-width">
                  <span class="info-label">String Domain:</span>
                  <span class="info-value string-domain">${asset.hubData.stringDomain}</span>
                </div>
              ` : ''}
              ${asset.hubData.isStartingLocation ? `
                <div class="info-item full-width">
                  <span class="badge badge-hub">‚≠ê Starting Location</span>
                </div>
              ` : ''}
              ${asset.hubData.primarySpecies ? `
                <div class="info-item">
                  <span class="info-label">Species:</span>
                  <span class="info-value">${asset.hubData.primarySpecies}</span>
                </div>
              ` : ''}
              ${asset.hubData.spawnRadius ? `
                <div class="info-item">
                  <span class="info-label">Spawn Radius:</span>
                  <span class="info-value">${asset.hubData.spawnRadius}</span>
                </div>
              ` : ''}
            </div>
          </div>
        `;
      }

      // Check if asset is connected to player's current location via travel chain
      let isConnected = false;
      let distance = null;
      let travelPath = [];
      let hopCount = 0;

      if (map.currentCharacter && map.currentCharacter.location) {
        const charX = map.currentCharacter.location.x;
        const charY = map.currentCharacter.location.y;
        const assetX = asset.x;
        const assetY = asset.y;

        // Calculate direct distance
        distance = Math.sqrt(Math.pow(assetX - charX, 2) + Math.pow(assetY - charY, 2));

        // Find if there's a connected path using BFS (breadth-first search)
        const result = window.findTravelPath(map.publishedAssets, charX, charY, asset._id);
        isConnected = result.connected;
        travelPath = result.path;
        hopCount = result.hops;
      }

      info.innerHTML = `
        <div class="zone-detail">
          <div class="asset-header">
            <div class="asset-icon-large">${icon}</div>
            <div class="asset-title-section">
              <h2 class="asset-title">${asset.title}</h2>
              <div class="asset-badges">
                <span class="badge badge-${asset.assetType}">${asset.assetType}</span>
                ${asset.subType ? `<span class="badge badge-subtype">${asset.subType}</span>` : ''}
                ${asset.rarity ? `<span class="badge badge-${asset.rarity}">${asset.rarity}</span>` : ''}
              </div>
            </div>
          </div>

          ${asset.assetType === 'galaxy' ? (
            // For galaxies: Check if character is at this location
            map.currentCharacter && distance < 50 ? `
              <div class="travel-action-bar">
                <button class="travel-btn explore-btn" onclick="window.location.href='/universe/galaxy/${asset._id}'">
                  <span class="travel-icon">üåå</span>
                  <span class="travel-text">Explore Galaxy</span>
                  <span class="travel-distance">Enter ${asset.title}</span>
                </button>
              </div>
            ` : map.currentCharacter && isConnected ? `
              <div class="travel-action-bar">
                <button class="travel-btn" onclick="window.travelToAsset('${asset._id}', '${asset.title}', ${asset.x}, ${asset.y})">
                  <span class="travel-icon">üöÄ</span>
                  <span class="travel-text">Travel to Galaxy</span>
                  <span class="travel-distance">${hopCount > 0 ? hopCount + ' hop' + (hopCount > 1 ? 's' : '') : Math.round(distance) + ' units'}</span>
                </button>
                ${hopCount > 0 ? `
                  <div class="travel-path-info">
                    <span class="path-label">Route:</span>
                    <span class="path-route">
                      ${travelPath.map((p, i) =>
                        i === 0 ? 'üìç ' + p.title :
                        i === travelPath.length - 1 ? 'üéØ ' + p.title :
                        '‚Üí ' + p.title
                      ).join(' ')}
                    </span>
                  </div>
                ` : ''}
              </div>
              <div class="exploration-hint">
                <span class="hint-icon">‚ÑπÔ∏è</span>
                <span class="hint-text">Travel here first to explore this galaxy</span>
              </div>
            ` : `
              <div class="travel-action-bar disabled">
                <div class="travel-unavailable">
                  <span class="travel-icon">üîí</span>
                  <span class="travel-text">Not Connected</span>
                  <span class="travel-distance">${Math.round(distance || 0)} units away</span>
                </div>
                <div class="travel-hint">
                  No travel route found. Assets must be within 800 units of each other to form a connected chain.
                </div>
              </div>
            `
          ) : (['orbital', 'planet', 'anomaly'].includes(asset.assetType) && map.currentCharacter && distance < 50) ? `
            <div class="travel-action-bar">
              <button class="travel-btn explore-btn" onclick="window.location.href='/zones/explore/planetary?asset=${asset._id}'">
                <span class="travel-icon">ü™ê</span>
                <span class="travel-text">Explore Area</span>
                <span class="travel-distance">Land on ${asset.title}</span>
              </button>
            </div>
            <div class="exploration-hint">
              <span class="hint-icon">üéÆ</span>
              <span class="hint-text">Land and explore this location on foot</span>
            </div>
          ` : (['orbital', 'planet', 'anomaly'].includes(asset.assetType) && map.currentCharacter && isConnected) ? `
            <div class="travel-action-bar">
              <button class="travel-btn" onclick="window.travelToAsset('${asset._id}', '${asset.title}', ${asset.x}, ${asset.y})">
                <span class="travel-icon">üöÄ</span>
                <span class="travel-text">Travel to Location</span>
                <span class="travel-distance">${hopCount > 0 ? hopCount + ' hop' + (hopCount > 1 ? 's' : '') : Math.round(distance) + ' units'}</span>
              </button>
              ${hopCount > 0 ? `
                <div class="travel-path-info">
                  <span class="path-label">Route:</span>
                  <span class="path-route">
                    ${travelPath.map((p, i) =>
                      i === 0 ? 'üìç ' + p.title :
                      i === travelPath.length - 1 ? 'üéØ ' + p.title :
                      '‚Üí ' + p.title
                    ).join(' ')}
                  </span>
                </div>
              ` : ''}
            </div>
            <div class="exploration-hint">
              <span class="hint-icon">‚ÑπÔ∏è</span>
              <span class="hint-text">Travel here first to explore this area</span>
            </div>
          ` : map.currentCharacter ? (isConnected ? `
            <div class="travel-action-bar">
              <button class="travel-btn" onclick="window.travelToAsset('${asset._id}', '${asset.title}', ${asset.x}, ${asset.y})">
                <span class="travel-icon">üöÄ</span>
                <span class="travel-text">Travel Here</span>
                <span class="travel-distance">${hopCount > 0 ? hopCount + ' hop' + (hopCount > 1 ? 's' : '') : Math.round(distance) + ' units'}</span>
              </button>
              ${hopCount > 0 ? `
                <div class="travel-path-info">
                  <span class="path-label">Route:</span>
                  <span class="path-route">
                    ${travelPath.map((p, i) =>
                      i === 0 ? 'üìç ' + p.title :
                      i === travelPath.length - 1 ? 'üéØ ' + p.title :
                      '‚Üí ' + p.title
                    ).join(' ')}
                  </span>
                </div>
              ` : ''}
            </div>
          ` : `
            <div class="travel-action-bar disabled">
              <div class="travel-unavailable">
                <span class="travel-icon">üîí</span>
                <span class="travel-text">Not Connected</span>
                <span class="travel-distance">${Math.round(distance)} units away</span>
              </div>
              <div class="travel-hint">
                No travel route found. Assets must be within 800 units of each other to form a connected chain.
              </div>
            </div>
          `) : ''}

          <div class="asset-meta-bar">
            <div class="meta-item">
              <span class="meta-icon">‚≠ê</span>
              <span class="meta-value">${asset.votes || 0} votes</span>
            </div>
            ${asset.category ? `
              <div class="meta-item">
                <span class="meta-icon">üìÇ</span>
                <span class="meta-value">${asset.category}</span>
              </div>
            ` : ''}
            ${asset.createdAt ? `
              <div class="meta-item">
                <span class="meta-icon">üìÖ</span>
                <span class="meta-value">${new Date(asset.createdAt).toLocaleDateString()}</span>
              </div>
            ` : ''}
          </div>

          ${asset.description ? `
            <div class="info-section">
              <p class="asset-description">${asset.description}</p>
            </div>
          ` : ''}

          ${positionHTML}
          ${hubHTML}
          ${statsHTML}
          ${effectsHTML}
          ${loreHTML}

          ${asset.tags && asset.tags.length > 0 ? `
            <div class="info-section">
              <h4>üè∑Ô∏è Tags</h4>
              <div class="tags-container">
                ${asset.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}
              </div>
            </div>
          ` : ''}

          ${asset.userId ? `
            <div class="info-section">
              <div class="creator-info">
                <span class="info-label">Created by:</span>
                <span class="info-value">${asset.userId === 'system' ? 'ü§ñ System' : asset.userId}</span>
              </div>
            </div>
          ` : ''}
        </div>
      `;
    }

    /**
     * Find travel path through connected assets using BFS
     * @param {Array} assets - All published assets
     * @param {number} startX - Starting X position
     * @param {number} startY - Starting Y position
     * @param {string} targetId - Target asset ID
     * @returns {Object} - { connected: boolean, path: Array, hops: number }
     */
    window.findTravelPath = function(assets, startX, startY, targetId) {
      const MAX_CONNECTION_DISTANCE = 800;

      // Find asset closest to start position (current character location)
      let startAsset = null;
      let minDist = Infinity;
      assets.forEach(a => {
        const d = Math.sqrt(Math.pow(a.x - startX, 2) + Math.pow(a.y - startY, 2));
        if (d < minDist) {
          minDist = d;
          startAsset = a;
        }
      });

      if (!startAsset) return { connected: false, path: [], hops: 0 };

      // If we're already at the target
      if (startAsset._id === targetId) {
        return { connected: true, path: [startAsset], hops: 0 };
      }

      // BFS to find shortest path
      const queue = [{ asset: startAsset, path: [startAsset] }];
      const visited = new Set([startAsset._id]);
      let foundPath = null;

      while (queue.length > 0 && !foundPath) {
        const { asset: current, path } = queue.shift();

        // Find all connected assets (within 800 units)
        for (const neighbor of assets) {
          if (visited.has(neighbor._id)) continue;

          const dist = Math.sqrt(
            Math.pow(neighbor.x - current.x, 2) +
            Math.pow(neighbor.y - current.y, 2)
          );

          if (dist < MAX_CONNECTION_DISTANCE) {
            const newPath = [...path, neighbor];
            visited.add(neighbor._id);

            // Found the target!
            if (neighbor._id === targetId) {
              foundPath = newPath;
              break;
            }

            queue.push({ asset: neighbor, path: newPath });
          }
        }
      }

      if (foundPath) {
        return {
          connected: true,
          path: foundPath,
          hops: foundPath.length - 1
        };
      }

      return { connected: false, path: [], hops: 0 };
    };

    /**
     * Handle travel to asset
     */
    window.travelToAsset = async function(assetId, assetTitle, assetX, assetY) {
      console.log('Traveling to:', assetTitle);

      if (!map.currentCharacter) {
        alert('No character selected for travel');
        return;
      }

      // Find the travel path using BFS
      const result = window.findTravelPath(
        map.publishedAssets,
        map.currentCharacter.location.x,
        map.currentCharacter.location.y,
        assetId
      );

      if (!result.connected || result.path.length === 0) {
        alert('Cannot travel - no connected path to destination');
        return;
      }

      // Start animated travel along the path
      console.log(`üöÄ Starting animated travel: ${result.path.length} waypoints, ${result.hops} hops`);

      // Remove current location from path (we're already there)
      // For a single jump, this leaves us with just [destination]
      const travelPath = result.path.slice(1);

      map.startTravelAnimation(travelPath, assetX, assetY, assetTitle, assetId);

      // Close info pane
      document.getElementById('infoPane').classList.remove('visible');

      // Show travel started notification
      window.showTravelNotification(`üöÄ Traveling to ${assetTitle} (${result.hops} hop${result.hops > 1 ? 's' : ''})...`);
    };

    /**
     * Show travel notification (global function accessible to map class)
     */
    window.showTravelNotification = function(message) {
      const notification = document.createElement('div');
      notification.className = 'travel-notification';
      notification.textContent = message;
      document.body.appendChild(notification);

      setTimeout(() => {
        notification.classList.add('show');
      }, 10);

      setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => notification.remove(), 300);
      }, 3000);
    };

    /**
     * Show selection menu for overlapping assets
     */
    function showAssetSelectionMenu(assets, x, y) {
      const menu = document.getElementById('assetSelectionMenu');
      const list = document.getElementById('assetSelectionList');

      // Get icon for asset type
      const getIcon = (asset) => {
        if (asset.assetType === 'galaxy') return 'üåå';
        if (asset.assetType === 'orbital') return 'üõ∞Ô∏è';
        if (asset.assetType === 'anomaly') return '‚ú®';
        if (asset.hubData?.isStartingLocation) return '‚ú¶';
        return '‚≠ê';
      };

      // Build list items
      list.innerHTML = assets.map((asset, index) => `
        <div class="selection-menu-item" onclick="window.selectAssetFromMenu(${index})">
          <span class="asset-icon">${getIcon(asset)}</span>
          <div class="asset-details">
            <div class="asset-title">${asset.title}</div>
            <div class="asset-type">${asset.assetType}${asset.subType ? ` - ${asset.subType}` : ''}</div>
          </div>
          <div class="asset-votes">‚≠ê ${asset.votes || 0}</div>
        </div>
      `).join('');

      // Store assets for selection
      window.currentOverlappingAssets = assets;

      // Position menu near click (or center if off-screen)
      const rect = map.canvas.getBoundingClientRect();
      let menuX = x || rect.width / 2;
      let menuY = y || rect.height / 2;

      // Keep menu on screen
      if (menuX + 300 > window.innerWidth) menuX = window.innerWidth - 320;
      if (menuY + 400 > window.innerHeight) menuY = window.innerHeight - 420;

      menu.style.left = menuX + 'px';
      menu.style.top = menuY + 'px';
      menu.style.display = 'block';
    }

    /**
     * Select asset from menu
     */
    window.selectAssetFromMenu = function(index) {
      console.log('selectAssetFromMenu called with index:', index);
      console.log('currentOverlappingAssets:', window.currentOverlappingAssets);
      
      if (!window.currentOverlappingAssets) {
        console.error('No currentOverlappingAssets array found');
        return;
      }
      
      const asset = window.currentOverlappingAssets[index];
      if (!asset) {
        console.error('No asset found at index:', index);
        return;
      }
      
      console.log('Selected asset:', asset.title);
      
      try {
        if (typeof window.displayAssetInfo === 'function') {
          window.displayAssetInfo(asset);
          window.closeSelectionMenu();
        } else {
          console.error('displayAssetInfo is not a function');
        }
      } catch (error) {
        console.error('Error displaying asset info:', error);
      }
    };

    /**
     * Close selection menu
     */
    window.closeSelectionMenu = function() {
      const menu = document.getElementById('assetSelectionMenu');
      menu.style.display = 'none';
      window.currentOverlappingAssets = null;
    };

    /**
     * Update debugger values
     */
    function updateDebugger() {
      if (!document.getElementById('debugGameStateSync')) return; // Only run if admin panel exists

      // Update assets count
      const assetsCount = map.publishedAssets ? map.publishedAssets.length : 0;
      document.getElementById('debugAssetsCount').textContent = assetsCount;

      // Update characters count
      const charactersCount = map.characters ? map.characters.length : 0;
      document.getElementById('debugCharactersCount').textContent = charactersCount;

      // Update FPS
      document.getElementById('debugFPS').textContent = map.fps || 30;

      // Update travel routes count
      const routesCount = map.travelConnections ? map.travelConnections.length : 0;
      document.getElementById('debugRoutesCount').textContent = routesCount;

      // Update last sync time
      const now = new Date();
      document.getElementById('debugLastSync').textContent = now.toLocaleTimeString();
    }

    <% if (user && user.isAdmin) { %>
    /**
     * Force state sync with game state service
     */
    async function forceStateSync() {
      const button = document.getElementById('forceStateSync');
      const syncStatus = document.getElementById('debugGameStateSync');

      button.disabled = true;
      button.textContent = 'üîÑ Syncing...';
      syncStatus.textContent = 'Syncing...';
      syncStatus.className = 'debug-value warning';

      try {
        // Force reload assets
        await map.loadPublishedAssets();

        // Force reload travel connections
        await map.loadTravelConnections();

        syncStatus.textContent = 'Synced ‚úì';
        syncStatus.className = 'debug-value';

        // Update debugger
        updateDebugger();

        console.log('‚úÖ Forced state sync complete');
      } catch (error) {
        console.error('Failed to sync:', error);
        syncStatus.textContent = 'Error ‚úó';
        syncStatus.className = 'debug-value error';
      } finally {
        button.disabled = false;
        button.textContent = 'üîÑ Force State Sync';
      }
    }

    // Setup force sync button
    const forceSyncBtn = document.getElementById('forceStateSync');
    if (forceSyncBtn) {
      forceSyncBtn.addEventListener('click', forceStateSync);
    }

    // Update debugger every 2 seconds
    setInterval(updateDebugger, 2000);
    <% } %>

    /**
     * Setup sync indicator
     */
    function setupSyncIndicator() {
      const syncStatus = document.getElementById('syncStatus');
      const syncDetails = document.getElementById('syncDetails');
      const mapDetails = document.getElementById('mapDetails');
      const syncRefreshBtn = document.getElementById('syncRefreshBtn');
      const syncIndicator = document.getElementById('syncIndicator');

      // If elements don't exist, this user is not a tester - return early
      if (!syncStatus || !syncDetails || !mapDetails || !syncRefreshBtn) {
        console.log('Sync indicator elements not found - user is not a tester');
        // Still define window.updateMapStatus as a no-op for compatibility
        window.updateMapStatus = function() {};
        return;
      }

      // Update map loading status
      window.updateMapStatus = function(status, details) {
        // Check if elements exist (they only exist for tester users)
        if (!syncStatus || !mapDetails) return;

        if (status === 'loading') {
          syncStatus.style.background = '#f59e0b';
          syncStatus.style.boxShadow = '0 0 8px #f59e0b';
          mapDetails.textContent = details || 'Loading assets...';
          mapDetails.style.color = '#f59e0b';
        } else if (status === 'loaded') {
          syncStatus.style.background = '#4ade80';
          syncStatus.style.boxShadow = '0 0 8px #4ade80';
          mapDetails.textContent = details || 'Positions loaded from DB';
          mapDetails.style.color = '#4ade80';
        } else if (status === 'error') {
          syncStatus.style.background = '#ef4444';
          syncStatus.style.boxShadow = '0 0 8px #ef4444';
          mapDetails.textContent = details || 'Error loading positions';
          mapDetails.style.color = '#ef4444';
        }
      };

      // Check sync status
      async function checkSync() {
        try {
          const response = await fetch('/api/v1/characters/check', {
            credentials: 'same-origin'
          });

          if (!response.ok) {
            throw new Error('Failed to check sync');
          }

          const data = await response.json();

          // Check if elements exist before updating
          if (!syncStatus || !syncDetails) return;

          // Update indicator based on sync status
          if (data.gameState.status === 'connected' && data.sync.inSync) {
            syncStatus.className = 'sync-connected';
            syncDetails.textContent = `‚úì Game State Synced (${data.local.count} chars)`;
            syncDetails.style.color = '#4ade80';

            <% if (user && user.isAdmin) { %>
            // Update debugger
            const debugGameStateSync = document.getElementById('debugGameStateSync');
            if (debugGameStateSync) {
              debugGameStateSync.textContent = 'Connected ‚úì';
              debugGameStateSync.className = 'debug-value';
            }
            <% } %>
          } else if (data.gameState.status === 'connected' && !data.sync.inSync) {
            syncStatus.className = 'sync-warning';
            syncDetails.textContent = `‚ö† Out of Sync (${data.sync.issues.length} issues)`;
            syncDetails.style.color = '#f59e0b';
            console.warn('Sync issues:', data.sync.issues);

            <% if (user && user.isAdmin) { %>
            // Update debugger
            const debugGameStateSync = document.getElementById('debugGameStateSync');
            if (debugGameStateSync) {
              debugGameStateSync.textContent = `Out of Sync (${data.sync.issues.length} issues)`;
              debugGameStateSync.className = 'debug-value warning';
            }
            <% } %>
          } else {
            syncStatus.className = 'sync-error';
            syncDetails.textContent = `‚úó Game State ${data.gameState.status}`;
            syncDetails.style.color = '#ef4444';

            <% if (user && user.isAdmin) { %>
            // Update debugger
            const debugGameStateSync = document.getElementById('debugGameStateSync');
            if (debugGameStateSync) {
              debugGameStateSync.textContent = `${data.gameState.status} ‚úó`;
              debugGameStateSync.className = 'debug-value error';
            }
            <% } %>
          }

        } catch (error) {
          console.error('Sync check error:', error);
          // Check if elements exist before updating
          if (!syncStatus || !syncDetails) return;

          syncStatus.className = 'sync-error';
          syncDetails.textContent = '‚úó Connection Error';
          syncDetails.style.color = '#ef4444';

          <% if (user && user.isAdmin) { %>
          // Update debugger
          const debugGameStateSync = document.getElementById('debugGameStateSync');
          if (debugGameStateSync) {
            debugGameStateSync.textContent = 'Connection Error ‚úó';
            debugGameStateSync.className = 'debug-value error';
          }
          <% } %>
        }
      }

      // Initial check
      checkSync();

      // Check every 30 seconds
      setInterval(checkSync, 30000);

      // Refresh button
      if (syncRefreshBtn) {
        syncRefreshBtn.addEventListener('click', () => {
          if (syncDetails) {
            syncDetails.textContent = 'Checking...';
            syncDetails.style.color = '#888';
          }
          if (mapDetails) {
            mapDetails.textContent = 'Refreshing...';
            mapDetails.style.color = '#888';
          }
          checkSync();

          // Also reload map assets
          if (window.map && window.map.loadPublishedAssets) {
            window.map.loadPublishedAssets();
          }
        });
      }
    }
  </script>
</body>
</html>
