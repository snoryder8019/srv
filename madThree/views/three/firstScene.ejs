<script>
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let modelRotation = { x: 0, y: Math.PI }; // Start Y rotation at 180 degrees
    let previousTouchPosition = { x: 0, y: 0 }; // For mobile touch events
    let isFollowingPath = true; // Track if the camera is following the path
  
    const scene = new THREE.Scene();
  
    // Set up the camera
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 2, 10); // Initial camera position
  
    // Create a renderer with antialiasing enabled and alpha for transparency
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio); // Ensure sharp rendering on high-DPI devices
    renderer.setClearColor(0x000000, 0); // Transparent background for renderer
    document.body.appendChild(renderer.domElement);
  
    // Make the canvas responsive to window resizing
    window.addEventListener('resize', () => {
      const width = window.innerWidth;
      const height = window.innerHeight;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    });
  
    // Add lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 2); // Soft light
    scene.add(ambientLight);
  
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(1, 1, 1).normalize();
    scene.add(directionalLight);
  
    // Define a path for the camera to follow using CatmullRomCurve3
    const pathPoints = [
      new THREE.Vector3(10, 5, 20),   // Start far from the model
      new THREE.Vector3(5, 3, 10),    // Move closer
      new THREE.Vector3(0, 2, 5),     // Sweep past the model
      new THREE.Vector3(-5, 2, 0),    // Continue past
      new THREE.Vector3(-10, 5, -10)  // Move away
    ];
  
    const cameraPath = new THREE.CatmullRomCurve3(pathPoints);
  
    // Load the GLTF model
    let model;
const loader = new THREE.GLTFLoader();
loader.load('/threeDModels/beaker_pack.glb', function (gltf) {
  model = gltf.scene;
  scene.add(model);

  model.traverse(function (node) {
    if (node.isMesh) {
      node.material = new THREE.MeshPhysicalMaterial({
        color: 0xffffff, // Adjust color if needed
        metalness: 0.1, // Low metalness for a glassy effect
        roughness: 0.1, // Lower roughness for a smooth, reflective surface
        transmission: 1, // Enable transmission for glass-like effect (1 = fully transparent)
        thickness: 1.0, // Thickness of the glass material
        opacity: 1.55, // Set opacity for transparency
        transparent: true, // Allow material transparency
        reflectivity: 0.9, // High reflectivity for shiny glass
        clearcoat: 1, // Add a clearcoat layer for extra glossiness
        clearcoatRoughness: 0, // Clearcoat smoothness
        envMapIntensity: 1, // Intensity of environment map reflections (if available)
      });
    }
  });

  model.position.set(0, 0, 0); // Keep it centered
  model.scale.set(0.6, 0.6, 0.6); // Scale the model down
  model.rotation.y = Math.PI; // Rotate the model 180 degrees on the Y-axis
}, undefined, function (error) {
  console.error('An error happened while loading the model', error);
});

  
    const canvas = renderer.domElement;
  
    // Helper function for handling both mouse and touch drag events
    function getTouchOrMousePosition(event) {
      return event.touches ? { x: event.touches[0].clientX, y: event.touches[0].clientY } : { x: event.clientX, y: event.clientY };
    }
  
    // Handle scrollwheel zooming and touch pinch zoom
    canvas.addEventListener('wheel', function (event) {
      const delta = event.deltaY * 0.01; // Adjust zoom sensitivity
      camera.position.z += delta; // Move the camera in/out on Z-axis
    });
  
    // Handle mouse and touch for dragging/rotating the model
    canvas.addEventListener('mousedown', function (event) {
      if (event.target.tagName === 'INPUT' || event.target.tagName === 'BUTTON') return;
      isDragging = true;
      previousMousePosition = getTouchOrMousePosition(event);
    });
  
    canvas.addEventListener('mousemove', function (event) {
      if (isDragging && model) {
        const currentMousePosition = getTouchOrMousePosition(event);
        const deltaMove = {
          x: currentMousePosition.x - previousMousePosition.x,
          y: currentMousePosition.y - previousMousePosition.y
        };
  
        modelRotation.y += deltaMove.x * 0.01;
        modelRotation.x += deltaMove.y * 0.01;
  
        model.rotation.y = modelRotation.y;
        model.rotation.x = modelRotation.x;
  
        previousMousePosition = currentMousePosition;
      }
    });
  
    canvas.addEventListener('mouseup', function () {
      isDragging = false;
    });
  
    canvas.addEventListener('mouseleave', function () {
      isDragging = false;
    });
  
    // Touch support for dragging on mobile
    canvas.addEventListener('touchstart', function (event) {
      isDragging = true;
      previousTouchPosition = getTouchOrMousePosition(event);
    });
  
    canvas.addEventListener('touchmove', function (event) {
      if (isDragging && model) {
        const currentTouchPosition = getTouchOrMousePosition(event);
        const deltaMove = {
          x: currentTouchPosition.x - previousTouchPosition.x,
          y: currentTouchPosition.y - previousTouchPosition.y
        };
  
        modelRotation.y += deltaMove.x * 0.01;
        modelRotation.x += deltaMove.y * 0.01;
  
        model.rotation.y = modelRotation.y;
        model.rotation.x = modelRotation.x;
  
        previousTouchPosition = currentTouchPosition;
      }
    });
  
    canvas.addEventListener('touchend', function () {
      isDragging = false;
    });
  
    // Handle camera path via slider
    const slider = document.getElementById('slider');
    const sliderValue = document.getElementById('sliderValue');
  
    slider.addEventListener('input', function () {
      const t = slider.value / 100; // Normalize slider value (0-100) to a range of 0-1
      sliderValue.textContent = `${slider.value}%`;
  
      const positionOnPath = cameraPath.getPointAt(t);
      camera.position.copy(positionOnPath);  // Move camera to position on path
  
      const lookAtPoint = cameraPath.getPointAt((t + 0.01) % 1);
      camera.lookAt(lookAtPoint);
    });
  
    // Camera control buttons
    document.querySelector('.up').addEventListener('click', () => {
      camera.position.y += 0.5;
    });
  
    document.querySelector('.down').addEventListener('click', () => {
      camera.position.y -= 0.5;
    });
  
    document.querySelector('.left').addEventListener('click', () => {
      camera.position.x -= 0.5;
    });
  
    document.querySelector('.right').addEventListener('click', () => {
      camera.position.x += 0.5;
    });
  
    document.querySelector('.zoomIn').addEventListener('click', () => {
      camera.position.z -= 0.5;
    });
  
    document.querySelector('.zoomOut').addEventListener('click', () => {
      camera.position.z += 0.5;
    });
  
    // Animation loop
    const animate = function () {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    };
  
    animate();
  </script>
  